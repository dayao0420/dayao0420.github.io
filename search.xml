<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unicode、utf8、ASCLL的区别</title>
    <url>/2020/10/28/kuku_class_homework_dayao/class2_homework/class2-Unicode%E3%80%81utf8%E3%80%81ASCLL%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Unicode、utf8、ASCLL的区别"><a href="#Unicode、utf8、ASCLL的区别" class="headerlink" title="Unicode、utf8、ASCLL的区别"></a>Unicode、utf8、ASCLL的区别</h1><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p><strong>Unicode</strong>，中文又称<strong>万国码</strong>、<strong>国际码</strong>、<strong>统一码</strong>、<strong>单一码</strong>，是<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8">计算机科学</a>领域里的一项业界标准。它对世界上大部分的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E7%B3%BB%E7%B5%B1">文字系统</a>进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。</p>
<p>Unicode伴随着<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86">通用字符集</a>的标准而发展，同时也以书本的形式[<a href="https://zh.wikipedia.org/wiki/Unicode#cite_note-1">1]</a>对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2020年3月公布的13.0.0[<a href="https://zh.wikipedia.org/wiki/Unicode#cite_note-2">2]</a>，已经收录超过13万个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">字符</a>（第十万个字符在2005年获采纳）。Unicode涵盖的资料除了视觉上的字形、编码方法、标准的<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码</a>外，还包含了字符特性，如大小写字母。</p>
<p>Unicode的发展由非营利机构<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E7%A2%BC%E8%81%AF%E7%9B%9F">统一码联盟</a>负责，该机构致力于让Unicode方案取代既有的字符编码方案。因为既有的方案往往空间非常有限，亦不适用于<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%AA%9E">多语</a>环境。</p>
<p>Unicode备受认可，并广泛地应用于电脑软件的<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E5%8C%96%E8%88%87%E6%9C%AC%E5%9C%B0%E5%8C%96">国际化与本地化</a>过程。有很多新科技，如<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">可扩展置标语言</a>（Extensible Markup Language，简称：XML）、<a href="https://zh.wikipedia.org/wiki/Java">Java编程语言</a>以及现代的<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>，都采用Unicode编码。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p> UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用一至四个字节对Unicode字符集中的所有有效编码点进行编码，属于Unicode标准的一部分，最初由肯·汤普逊和罗布·派克提出。由于较小值的编码点一般使用频率较高，直接使用Unicode编码效率低下，大量浪费内存空间。UTF-8就是为了解决向后兼容ASCII码而设计，Unicode中前128个字符（与ASCII码一一对应），使用与ASCII码相同的二进制值的单个字节进行编码，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字优先采用的编码方式。 自2009年以来，UTF-8一直是万维网的最主要的编码形式（对所有，而不仅是Unicode范围内的编码）（并由WHATWG宣布为强制性的“适用于所有事物(for all things)”，截止到2019年11月， 在所有网页中，UTF-8编码应用率高达94.3%（其中一些仅是ASCII编码，因为它是UTF-8的子集），而在排名最高的1000个网页中占96％。 第二热门的多字节编码方式Shift JIS和GB 2312分别具有0.3％和0.2％的占有率。Internet邮件联盟（ Internet Mail Consortium, IMC）建议所有电子邮件程序都能够使用UTF-8展示和创建邮件，W3C建议UTF-8作为XML文件和HTML文件的默认编码方式。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码，互联网邮件联盟（IMC）建议所有电子邮件软件都支持UTF-8编码。</p>
<h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a><strong>ASCII码</strong></h2><p>我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</p>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。</p>
<p>ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript语言层面的基本错误类型</title>
    <url>/2020/10/28/kuku_class_homework_dayao/class2_homework/class2-JavaScript%E8%AF%AD%E8%A8%80%E5%B1%82%E9%9D%A2%E7%9A%84%E5%9F%BA%E7%A1%80%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Javascript语言层面的基本错误类型"><a href="#Javascript语言层面的基本错误类型" class="headerlink" title="Javascript语言层面的基本错误类型"></a>Javascript语言层面的基本错误类型</h1><p>js中的控制台的报错信息主要分为两大类，第一类是语法错误，这一类错误在预解析的过程中如果遇到，就会导致整个js文件都无法执行。另一类错误统称为异常，这一类的错误会导致在错误出现的那一行之后的代码无法执行，但在那一行之前的代码不会受到影响。</p>
<h2 id="1-SyntaxError：语法错误"><a href="#1-SyntaxError：语法错误" class="headerlink" title="1. SyntaxError：语法错误"></a>1. SyntaxError：语法错误</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. Syntax Error: 语法错误</span><br><span class="line">&#x2F;&#x2F; 1.1 变量名不符合规范</span><br><span class="line">var 1                          &#x2F;&#x2F; Uncaught SyntaxError: Unexpected number</span><br><span class="line">var 1a                         &#x2F;&#x2F; Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">&#x2F;&#x2F; 1.2 给关键字赋值</span><br><span class="line">function &#x3D; 5                   &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token &#x3D;  </span><br></pre></td></tr></table></figure>

<h2 id="2-Uncaught-ReferenceError：引用错误"><a href="#2-Uncaught-ReferenceError：引用错误" class="headerlink" title="2. Uncaught ReferenceError：引用错误"></a>2. Uncaught ReferenceError：引用错误</h2><p>引用一个不存在的变量时发生的错误。将一个值分配给无法分配的对象，比如对函数的运行结果或者函数赋值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2.1 引用了不存在的变量</span><br><span class="line">a()                            &#x2F;&#x2F; Uncaught ReferenceError: a is not defined</span><br><span class="line">console.log(b)                 &#x2F;&#x2F; Uncaught ReferenceError: b is not defined</span><br><span class="line">&#x2F;&#x2F; 2.2 给一个无法被赋值的对象赋值</span><br><span class="line">console.log(&quot;abc&quot;) &#x3D; 1         &#x2F;&#x2F; Uncaught ReferenceError: Invalid left-hand side in assignment</span><br></pre></td></tr></table></figure>

<h2 id="3-RangeError：范围错误"><a href="#3-RangeError：范围错误" class="headerlink" title="3. RangeError：范围错误"></a>3. RangeError：范围错误</h2><p>RangeError是当一个只超出有效范围时发生的错误。主要的有几种情况，第一是数组长度为负数，第二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 3.1 数组长度为负数</span><br><span class="line">[].length &#x3D; -5                        &#x2F;&#x2F; Uncaught RangeError: Invalid array length</span><br><span class="line">&#x2F;&#x2F; 3.2 Number对象的方法参数超出范围</span><br><span class="line">var num &#x3D; new Number(12.34)</span><br><span class="line">console.log(num.toFixed(-1))          &#x2F;&#x2F; Uncaught RangeError: toFixed() digits argument must be between 0 and 20 at Number.toFixed</span><br><span class="line">&#x2F;&#x2F; 说明: toFixed方法的作用是将数字四舍五入为指定小数位数的数字,参数是小数点后的位数,范围为0-20.</span><br></pre></td></tr></table></figure>

<h2 id="4-TypeError类型错误"><a href="#4-TypeError类型错误" class="headerlink" title="4.TypeError类型错误"></a>4.TypeError类型错误</h2><p>变量或参数不是预期类型时发生的错误。比如使用new字符串、布尔值等原始类型和调用对象不存在的方法就会抛出这种错误，因为new命令的参数应该是一个构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 4.1 调用不存在的方法</span><br><span class="line">123()                                &#x2F;&#x2F; Uncaught TypeError: 123 is not a function</span><br><span class="line">var o &#x3D; &#123;&#125;</span><br><span class="line">o.run()                              &#x2F;&#x2F; Uncaught TypeError: o.run is not a function</span><br><span class="line">&#x2F;&#x2F; 4.2 new关键字后接基本类型</span><br><span class="line">var p &#x3D; new 456                      &#x2F;&#x2F; Uncaught TypeError: 456 is not a constructor</span><br></pre></td></tr></table></figure>

<h2 id="5-URIError，URL错误"><a href="#5-URIError，URL错误" class="headerlink" title="5. URIError，URL错误"></a>5. URIError，URL错误</h2><p>主要是相关函数的参数不正确。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decodeURI(&quot;%&quot;)                   &#x2F;&#x2F; Uncaught URIError: URI malformed at decodeURI</span><br></pre></td></tr></table></figure>

<p>URI相关参数不正确时抛出的错误，主要涉及encodeURI、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape(）六个函数。</p>
<h2 id="6-EvalError-eval-函数执行错误"><a href="#6-EvalError-eval-函数执行错误" class="headerlink" title="6.EvalError eval()函数执行错误"></a>6.EvalError eval()函数执行错误</h2><p>在ES5以下的JavaScript中，当eval()函数没有被正确执行时，会抛出evalError错误。 例如下面的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myEval &#x3D; eval;</span><br><span class="line">myEval(&quot;alert(&#39;call eval&#39;)&quot;);</span><br></pre></td></tr></table></figure>

<p>需要注意的是：ES5以上的JavaScript中已经不再抛出该错误，但依然可以通过new关键字来自定义该类型的错误提示。</p>
<p>以上的6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，认为生成错误对象的实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Error([message[,fileName[,lineNumber]]])，</span><br></pre></td></tr></table></figure>

<p>第一个参数表示错误提示信息，第二个是文件名，第三个是行号</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>ESLint及其基本用法</title>
    <url>/2020/10/28/kuku_class_homework_dayao/class2_homework/class2-ESLint%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="ESLint及其基本用法"><a href="#ESLint及其基本用法" class="headerlink" title="ESLint及其基本用法"></a>ESLint及其基本用法</h1><p>ESLint 官网的简介：</p>
<blockquote>
<p>代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。</p>
</blockquote>
<blockquote>
<p>JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。</p>
</blockquote>
<p>因为 JavaScript 这门神奇的语言，在带给我们灵活性的同时，也埋下了一些坑。比如 <code>==</code> 涉及到的弱类型转换，着实让人很苦恼，还有 <code>this</code> 的指向，也是一个让人迷惑的东西。而 Lint 工具就很好的解决了这个问题，干脆禁止你使用 <code>==</code> ，这种做法虽然限制了语言的灵活性，但是带来的收益也是可观的。</p>
<p>还有就是作为一门动态语言，因为缺少编译过程，有些本可以在编译过程中发现的错误，只能等到运行才发现，这给我们调试工作增加了一些负担，而 Lint 工具相当于为语言增加了编译过程，在代码运行前进行静态分析找到出错的地方。</p>
<p>所以汇总一下，Lint工具的优势：</p>
<h4 id="1-避免低级bug，找出可能发生的语法错误"><a href="#1-避免低级bug，找出可能发生的语法错误" class="headerlink" title="1. 避免低级bug，找出可能发生的语法错误"></a>1. 避免低级bug，找出可能发生的语法错误</h4><blockquote>
<p>使用未声明变量、修改 const 变量……</p>
</blockquote>
<h4 id="2-提示删除多余的代码"><a href="#2-提示删除多余的代码" class="headerlink" title="2. 提示删除多余的代码"></a>2. 提示删除多余的代码</h4><blockquote>
<p>声明而未使用的变量、重复的 case ……</p>
</blockquote>
<h4 id="3-确保代码遵循最佳实践"><a href="#3-确保代码遵循最佳实践" class="headerlink" title="3. 确保代码遵循最佳实践"></a>3. 确保代码遵循最佳实践</h4><blockquote>
<p>可参考 <a href="https://github.com/airbnb/javascript">airbnb style</a>、<a href="https://github.com/standard/standard">javascript standard</a></p>
</blockquote>
<h4 id="4-统一团队的代码风格"><a href="#4-统一团队的代码风格" class="headerlink" title="4. 统一团队的代码风格"></a>4. 统一团队的代码风格</h4><blockquote>
<p>加不加分号？使用 tab 还是空格？</p>
</blockquote>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>说了那么多，还是来看下有点实际意义的，ESLint 到底是如何使用的。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>如果想在现有项目中引入 ESLint，可以直接运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 全局安装 ESLint</span><br><span class="line">$ npm install -g eslint</span><br><span class="line"></span><br><span class="line"># 进入项目</span><br><span class="line">$ cd ~&#x2F;Code&#x2F;ESLint-demo</span><br><span class="line"></span><br><span class="line"># 初始化 package.json</span><br><span class="line">$ npm init -f</span><br><span class="line"></span><br><span class="line"># 初始化 ESLint 配置</span><br><span class="line">$ eslint --init</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript中的原型链</title>
    <url>/2020/10/28/kuku_class_homework_dayao/class2_homework/class2-Javascript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h1 id="Javascript中的原型链"><a href="#Javascript中的原型链" class="headerlink" title="Javascript中的原型链"></a>Javascript中的原型链</h1><h2 id="1、原型、原型链相等关系理解"><a href="#1、原型、原型链相等关系理解" class="headerlink" title="1、原型、原型链相等关系理解"></a>1、原型、原型链相等关系理解</h2><h4 id="四个概念"><a href="#四个概念" class="headerlink" title="四个概念"></a><strong>四个概念</strong></h4><p>1.js分为<strong>函数对象</strong>和<strong>普通对象</strong>，每个对象都有__proto__属性，但是只有函数对象才有prototype属性</p>
<p>2.Object、Function都是js内置的<strong>函数</strong>, 类似的还有我们常用到的Array、RegExp、Date、Boolean、Number、String</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">那么__proto__和prototype到底是什么，两个概念理解它们</span><br></pre></td></tr></table></figure>

<p>3.属性__proto__是一个对象，它有两个属性，constructor和__proto__；</p>
<p>4.原型对象prototype有一个默认的constructor属性，用于记录实例是由哪个构造函数创建；</p>
<blockquote>
<p>有以下构造函数Person，他的原型上有所属国属性motherland=’china’</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age)&#123; </span><br><span class="line">   this.name &#x3D; name;</span><br><span class="line">   this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.motherland &#x3D; &#39;china&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过new Person()创建的person01实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let person01 &#x3D; new Person(&#39;小明&#39;, 18);</span><br></pre></td></tr></table></figure>

<h4 id="两个准则"><a href="#两个准则" class="headerlink" title="两个准则"></a><strong>两个准则</strong></h4><p>js之父在设计js原型、原型链的时候遵从以下两个准则</p>
<ol>
<li>Person.prototype.constructor == Person // <strong>准则1：原型对象（即Person.prototype）的constructor指向构造函数本身</strong></li>
<li>person01.<em>*proto</em>* == Person.prototype // <strong>准则2：实例（即person01）的__proto__和原型对象指向同一个地方</strong> 复制代码</li>
</ol>
<p>记住以上<strong>四个概念两个准则</strong>，任何原型链相等判断都能判断正确。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>​        <strong>所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）</strong></p>
<p>​        <strong>所有函数拥有prototype属性（显式原型）（仅限函数）</strong></p>
<p>​        <strong>原型对象：拥有prototype属性的对象，在定义函数时就被创建</strong></p>
<p>除了Object的原型对象（Object.prototype）的__proto__指向null，其他内置函数对象的原型对象（例如：Array.prototype）和自定义构造函数的 __proto__都指向Object.prototype, 因为原型对象本身是普通对象。 即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.__proto__ &#x3D; null;</span><br><span class="line">Array.prototype.__proto__ &#x3D; Object.prototype;</span><br><span class="line">Foo.prototype.__proto__  &#x3D; Object.prototype;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>原型链的核心其实就只有一个：属性共享和独立的控制，当你的对象实例需要独立的属性，所有做法的本质都是在对象实例里面创建属性。若不考虑太多，你大可以在Person里面直接定义你所需要独立的属性来覆盖掉原型的属性。总之，使用原型继承的时候，要对于原型中的属性要特别注意，因为他们都是牵一发而动全身的存在。现在最常用的方法是组合模式。</p>
<h3 id="1、原型链"><a href="#1、原型链" class="headerlink" title="1、原型链"></a>1、原型链</h3><h4 id="1）构造函数、原型和实例的关系"><a href="#1）构造函数、原型和实例的关系" class="headerlink" title="1）构造函数、原型和实例的关系"></a>1）构造函数、原型和实例的关系</h4><p>​    ①构造函数都有一个属性prototype，这个属性是一个对象（Object的实例）</p>
<p>​    ②原型对象prototype里面有一个constructor属性，该属性指向原型对象所属的构造函数</p>
<p>​    ③实例对象都有一个_proto_属性，该属性也指向构造函数的原型对象，它是一个非标准属性，不可以用于编程，它是用于浏览器自己使用的</p>
<h4 id="2）prototype与-proto-的关系"><a href="#2）prototype与-proto-的关系" class="headerlink" title="2）prototype与_proto_的关系"></a>2）prototype与_proto_的关系</h4><p>​    ①prototype是构造函数的属性</p>
<p>​    ②_proto_是实例对象的属性</p>
<p>​          ——这两者都指向同一个对象</p>
<p>  【总结】</p>
<p>​       i）函数也是对象，对象不一定是函数；</p>
<p>​      ii）对象的本质：无序的键值对集合；键值对当中的值可以是任意数据类型的值</p>
<p>​      iii）对象就是一个容器，这个容器当中放的是（属性和方法）</p>
<h4 id="3）属性搜索"><a href="#3）属性搜索" class="headerlink" title="3）属性搜索"></a>3）属性搜索</h4><p>  　　①在访问对象的某个成员的时候会先在对象中找是否存在</p>
<p>  　　②如果当前对象中没有就在构造函数的原型对象中找</p>
<p>  　　③如果原型对象中没有找到就到原型对象的原型上找</p>
<p>  　　④知道Object的原型对象的原型是null为止</p>
<h3 id="2、Function"><a href="#2、Function" class="headerlink" title="2、Function"></a>2、Function</h3><p>​                        ——所有函数都是Function的实例</p>
<p>  ①本地对象：独立于宿主环境（浏览器）的对象——包括Object、Array、Date、RegExp、Function、Error、Number、String、Boolean</p>
<p>  ②内置对象——包括Math、Global（window，在js中就是全局变量），使用的时候不需要new</p>
<p>  ③宿主对象——包括自定义对象、DOM、BOM</p>
<h1 id="2、es6的Object-defineProperty"><a href="#2、es6的Object-defineProperty" class="headerlink" title="2、es6的Object.defineProperty"></a>2、es6的Object.defineProperty</h1><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p><code>obj</code></p>
<p>要定义属性的对象。</p>
</li>
<li><p><code>prop</code></p>
<p>要定义或修改的属性的名称或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a> 。</p>
</li>
<li><p><code>descriptor</code></p>
<p>要定义或修改的属性描述符。以对象形式{}书写。</p>
<ul>
<li>value：设置属性的值，默认为undefined</li>
<li>writale：值是否可以重写，true｜false，默人为false</li>
<li>enumerable：目标属性是否可以枚举，true｜false，默人为false</li>
<li>configrable：目标属性是否可以被删除或是否可以再次修改特性true｜false，默认为false</li>
</ul>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>被传递给函数的对象。</p>
<p>在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而<code>Object.defineProperty</code> 是定义key为Symbol的属性的方法之一。</p>
<h2 id="Object-defineProperty方法"><a href="#Object-defineProperty方法" class="headerlink" title="Object.defineProperty方法"></a>Object.defineProperty方法</h2><h3 id="定义对象的属性"><a href="#定义对象的属性" class="headerlink" title="定义对象的属性"></a>定义对象的属性</h3><blockquote>
<p>定义对象的属性</p>
<p> ==&gt;<strong>方法1:</strong></p>
<p> //数据描述符</p>
<p> Object.defineProperty(要定义属性的对象,要定义的属性名,{</p>
<p> value:属性值,</p>
<p> writable:默认false，该属性的value是否能被赋值运算符改变</p>
<p> })</p>
<p> ==&gt;<strong>方法2:</strong></p>
<p> //存取描述符</p>
<p> Object.defineProperty(要定义属性的对象,要定义的属性名,{</p>
<p> get:function(){},</p>
<p> set:function(){}</p>
<p> })</p>
<p> ==&gt;Object.defineProperty的应用:数据的双向数据绑定</p>
<p> ==&gt;需求:在input里面输入内容,会显示在span里面</p>
<p> ==&gt;vue利用这个实现了数据的双向数据绑定,可以不用操作dom,直接通过数据模型就可以改变元素的内容</p>
</blockquote>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">//定义obj上的a属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    value:<span class="number">1</span>,</span><br><span class="line">    writable:<span class="literal">true</span> <span class="comment">//允许重写obj上属性a的值           </span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取obj上的属性a的值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a)</span><br><span class="line"><span class="comment">//重写obj上属性a的值</span></span><br><span class="line">obj.a = <span class="number">34</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a)</span><br><span class="line"><span class="comment">//遍历obj</span></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> key <span class="keyword">in</span> obj</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);<span class="comment">//没有特别说明,无法遍历出来a属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;text&#x27;</span>,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当读取obj的text的属性值的时候,会触发这个函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get方法被调用了&#x27;</span>);</span><br><span class="line">        <span class="comment">//return 的值,就是属性值</span></span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//set可以接收一个参数,就是你想赋的值</span></span><br><span class="line">        <span class="comment">//当设置obj的text的属性值的时候,会触发这个函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;set方法被调用了&#x27;</span>);</span><br><span class="line">        <span class="comment">//可以通过下面方法赋值,text变量就是obj的text的属性值</span></span><br><span class="line">        text = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.text = <span class="number">4546</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.text)</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-defineProperty的应用"><a href="#Object-defineProperty的应用" class="headerlink" title="Object.defineProperty的应用"></a>Object.defineProperty的应用</h3><blockquote>
<p><strong>数据的双向数据绑定,vue框架</strong></p>
<p><strong>需求</strong>:在input里面输入内容,会显示在span里面</p>
<p><strong>想法</strong>:发input的值变成一个对象的属性,只要input里面输入内容,就会触发set,在set里面更新span的内容</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> model = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(model,<span class="string">&#x27;txt&#x27;</span>,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;span&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        span.innerHTML = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">input.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    model.txt = input.value;<span class="comment">//必然触发set函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>每次输入将文本框中的value赋值给model.txt属性，触发执行det函数，并将input.value传给形参val，然后不断写入span标签中渲染页面，实现数据的双向绑定效果。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_44862403/article/details/107417108">https://blog.csdn.net/qq_44862403/article/details/107417108</a></p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript的基本错误类型与保留关键字</title>
    <url>/2020/10/28/kuku_class_homework_dayao/class2_homework/class2-Javascript%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="Javascript的基本错误类型与保留关键字"><a href="#Javascript的基本错误类型与保留关键字" class="headerlink" title="Javascript的基本错误类型与保留关键字"></a>Javascript的基本错误类型与保留关键字</h1><h2 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h2><p>JavaScript中的一切(变量、函数名、操作符)都区分大小写。例如，变量名itbsl和变量名ITbsl是两个不同的变量。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>所谓<strong>标识符</strong>，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符:</p>
<ul>
<li>第一字符必须是一个字母、下划线(_)、或一个美元符号($);</li>
<li>其它字符可以是字母、下划线、美元符号或数字；</li>
</ul>
<p>注意:</p>
<blockquote>
<p>不能把关键字、保留字、true、false和null用作标识符。</p>
</blockquote>
<h2 id="JS中的关键字"><a href="#JS中的关键字" class="headerlink" title="JS中的关键字"></a>JS中的关键字</h2><p>ECMA-262描述了一组具有特定用途的<strong>关键字</strong>，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是ECMAScript的全部关键字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break              case           catch       continue    debugger (第五版新增关键字)</span><br><span class="line">do                 default        delete      else        for         </span><br><span class="line">functionfinally    instanceofif   in          new         return </span><br><span class="line">switch             trythrowthis   typeof      varvoid     while        with</span><br></pre></td></tr></table></figure>

<h2 id="JS中的保留字"><a href="#JS中的保留字" class="headerlink" title="JS中的保留字"></a>JS中的保留字</h2><p>ECMA-262还描述了另外一组不能用作标识符的<strong>保留字</strong>。尽管保留字在这门语言中还没有任何特定的用途，但他们有可能在将来被用作关键字。一下是EMCA-262第三版定义的全部保留字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract      boolean      byte          class         const            </span><br><span class="line">char          debugger     double        extends       export     </span><br><span class="line">enum          final        float         goto          int</span><br><span class="line">import        interface    implements    longnative    package </span><br><span class="line">private       protected    public        static        short  </span><br><span class="line">synchronized  super        throws        transient     volatile </span><br></pre></td></tr></table></figure>

<p>第5版把在非严格模式下运行时的保留字缩减为下列这些:</p>
<figure class="highlight plain"><figcaption><span>enum          extends          super</span></figcaption><table><tr><td class="code"><pre><span class="line">class          enum          extends          super</span><br><span class="line">const          export        import</span><br></pre></td></tr></table></figure>

<p>在严格模式下，第5版还对以下保留字加了限制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implements          package          public</span><br><span class="line">interface           private          static</span><br><span class="line">let                 protected        yield</span><br></pre></td></tr></table></figure>

<p>除了上面列出的关键字和保留字，ECMA-262第5版对eval和arguments还施加了限制。在严格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。<br>建议:</p>
<blockquote>
<p>无论是在严格模式下还是在非严格模式下，都不要在定义变量名、函数名或者属性名时使用上面列举出的保留字，以免入坑。</p>
</blockquote>
<h2 id="主要整理下几个关键字："><a href="#主要整理下几个关键字：" class="headerlink" title="主要整理下几个关键字："></a><strong>主要整理下几个关键字：</strong></h2><h4 id="1、delete"><a href="#1、delete" class="headerlink" title="1、delete"></a><strong>1、delete</strong></h4><p><strong>删除对象（而非构造方法或原型）的某个属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">id,name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">	  <span class="built_in">this</span>.name = name;</span><br><span class="line">	  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objOne = <span class="keyword">new</span> obj(<span class="number">1</span>,<span class="string">&quot;objOneName&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> objTwo = <span class="keyword">new</span> obj(<span class="number">2</span>,<span class="string">&quot;objTwoName&quot;</span>);</span><br><span class="line">alert(<span class="string">&quot;objOne名字为：&quot;</span>+objOne.getName());<span class="comment">//提示objOneName</span></span><br><span class="line"><span class="keyword">delete</span> objTwo.name;</span><br><span class="line">alert(<span class="string">&quot;objOne名字为：&quot;</span>+objOne.getName());<span class="comment">//提示objOneName</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>只能删除自身定义的公有属性，即”this.属性名”定义的属性，而不能删除私有属性或通过proptotype定义的公有属性（已实践）。此外可删除直接在对象上添加的属性，如var a = new Object();a.name = “name”;delete a.name;</p>
<h4 id="2、throw-与-try…catch…finally"><a href="#2、throw-与-try…catch…finally" class="headerlink" title="2、throw 与 try…catch…finally"></a><strong>2、throw 与 try…catch…finally</strong></h4><p><strong>操作异常</strong></p>
<p>JS 的几种具体异常类型（都继承自Error 异常类）：</p>
<p>（1）、SyntaxError：语法错误，如代码中不小心按了个特殊符号；</p>
<p>（2）、ReferenceError：引用错误，常见提示：Uncaught ReferenceError: a is not defined；</p>
<p>（3）、RangeError：范围错误，常见对数组的操作等；</p>
<p>（4）、TypeError：类型错误，如：xxx is not a function；</p>
<p>（5）、.URLError：与url相关参数不正确，主要是encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数；</p>
<p>（6）、EvalError：全局函数eval 执行错误（注：eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码）。</p>
<p>throw 可抛出自定义对象，并可通过catch捕获：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CommonException</span>(<span class="params">message, code</span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.message = message;  </span><br><span class="line">        <span class="built_in">this</span>.code = code;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">var</span> exception = <span class="keyword">new</span> CommonException(<span class="string">&#x27;您的代码出错啦&#x27;</span>, <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">throw</span> exception;  </span><br><span class="line">        alert(<span class="string">&#x27;这地方的代码将不会执行到&#x27;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;  </span><br><span class="line">        alert(e.message);  </span><br><span class="line">        alert(e.code)  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;  </span><br></pre></td></tr></table></figure>

<p>（参考：<a href="http://blog.csdn.net/zhang197093/article/details/52055850">http://blog.csdn.net/zhang197093/article/details/52055850）</a></p>
<h4 id="3、in"><a href="#3、in" class="headerlink" title="3、in"></a><strong>3、in</strong></h4><p><strong>与for 一起使用用于遍历对象的属性名</strong></p>
<p>（1）、使用点一：在js中，for……in用于遍历一个对象的属性，把对象的属性名和属性值都提出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:<span class="string">&quot;value2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key3&quot;</span>:<span class="string">&quot;value3&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//属性名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EnumaKey</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> key <span class="keyword">in</span> obj </span>)</span>&#123;</span><br><span class="line">        alert(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EnumaVal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> key <span class="keyword">in</span> obj </span>)</span>&#123;</span><br><span class="line">        alert(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点：</strong>在使用for in遍历对象时候，对象有一个重要的方法：hasOwnProperty()。该方法可以在遍历对象属性的时候可以过滤掉从原型链上下来的属性。</p>
<p> （2）、使用点二：判断某个对象是否具有某个属性</p>
<p>对于一般的对象属性需要用字符串指定属性的名称  如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var mycar = &#123;make: <span class="string">&quot;Honda&quot;</span>, model: <span class="string">&quot;Accord&quot;</span>, year: 1998&#125;;</span><br><span class="line"><span class="string">&quot;make&quot;</span> <span class="keyword">in</span> mycar  // returns <span class="literal">true</span></span><br><span class="line"><span class="string">&quot;model&quot;</span> <span class="keyword">in</span> mycar // returns <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>对于数组对象，元素值对应的属性名为数字类型，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Arrays</span><br><span class="line">var trees = new Array(<span class="string">&quot;redwood&quot;</span>, <span class="string">&quot;bay&quot;</span>, <span class="string">&quot;cedar&quot;</span>, <span class="string">&quot;oak&quot;</span>, <span class="string">&quot;maple&quot;</span>);</span><br><span class="line">0 <span class="keyword">in</span> trees        // returns <span class="literal">true</span></span><br><span class="line">3 <span class="keyword">in</span> trees        // returns <span class="literal">true</span></span><br><span class="line">6 <span class="keyword">in</span> trees        // returns <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;bay&quot;</span> <span class="keyword">in</span> trees    // returns <span class="literal">false</span> (you must specify the index number,</span><br><span class="line">                  // not the value at that index)</span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> trees // returns <span class="literal">true</span> (length is an Array property)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>in 的右边必须是一个对象，如：你可以指定一个用String构造器生成的，但是不能指定字符串直接量的形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var color1 = new String(<span class="string">&quot;green&quot;</span>);</span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> color1 // returns <span class="literal">true</span></span><br><span class="line">var color2 = <span class="string">&quot;coral&quot;</span>;</span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> color2 // generates an error (color is not a String object)</span><br></pre></td></tr></table></figure>

<p>此外，如果你使用delete操作符删除了一个属性，再次用in检查时，会返回false；</p>
<p>如果你把一个属性值设为undefined，但是没有使用delete操作符，使用in检查，会返回true。</p>
<p>（参考：<a href="http://www.cnblogs.com/renxiaoren/p/5942767.html%EF%BC%89">http://www.cnblogs.com/renxiaoren/p/5942767.html）</a></p>
<h4 id="4、instanceof"><a href="#4、instanceof" class="headerlink" title="**4、instanceof **"></a>**4、instanceof **</h4><p><strong>返回的是布尔值，而typeof 返回的是几种数据类型的字符串值。</strong></p>
<h4 id="5、with"><a href="#5、with" class="headerlink" title="5、with"></a><strong>5、with</strong></h4><p><strong>引用一个对象，使访问属性与方法更加方便（只能访问与修改属性，不能增加属性与方法）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> obj(id,name)&#123;</span><br><span class="line">	this.id = id;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.getName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">	    <span class="built_in">return</span> this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var myObj = new obj(3,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">with(myObj)&#123;</span><br><span class="line">	alert(id);//提示3</span><br><span class="line">	alert(name);//提示three</span><br><span class="line">	alert(getName());//提示three</span><br><span class="line">	id = 4;</span><br><span class="line">	alert(id);//提示4</span><br><span class="line">&#125;</span><br><span class="line">alert(myObj.id);//提示4，说明with中是通过引用方式访问的，而不是复制值的方式</span><br></pre></td></tr></table></figure>

<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://blog.csdn.net/qq_33242126/article/details/82799578">https://blog.csdn.net/qq_33242126/article/details/82799578</a></p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON是什么，和XML，YAML的区别</title>
    <url>/2020/10/28/kuku_class_homework_dayao/class2_homework/class2-JSON%E3%80%81XML%EF%BC%8CYAML%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="JSON是什么，和XML，YAML的区别"><a href="#JSON是什么，和XML，YAML的区别" class="headerlink" title="JSON是什么，和XML，YAML的区别"></a>JSON是什么，和XML，YAML的区别</h1><h5 id="三者都是序列化语言"><a href="#三者都是序列化语言" class="headerlink" title="三者都是序列化语言"></a>三者都是序列化语言</h5><ul>
<li><p>JSON:J”avascript Object Notation”(javascript对象表示法) (.json)</p>
</li>
<li><p>XML:”EXtensible Markup Language”(可扩展标记语言) (.xml)</p>
</li>
<li><p>YAML:”YAML Ain’t a Markup Language”(YAML 不是一种标记语言) (.yaml)</p>
</li>
<li><p>YAML使用缩进来定义结构化数据，因此每个YAML中的数据块通过空白的数量来区分</p>
</li>
<li><p>三者文件的扩展名都与其名称对应， .yaml for YAML, .json for JSON, .xml for XML，比较容易记忆。</p>
</li>
<li><p>实际上，三者的扩展名都是比较随意的，对开发者和应用来说重要的是其文件格式，内容类型和数据结构。(译者按，重要的是内容，例如.yml和.yaml几乎无差别。.js的文件中依然可以存储json).</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3></li>
</ul>
<p>1.代码书写方式不同</p>
<blockquote>
<p>**JSON: **</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;sites&quot;: [</span><br><span class="line">    &#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;, </span><br><span class="line">    &#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;, </span><br><span class="line">    &#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>XML:</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;name&gt;菜鸟教程&lt;&#x2F;name&gt; &lt;url&gt;www.runoob.com&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;&#x2F;site&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;name&gt;google&lt;&#x2F;name&gt; &lt;url&gt;www.google.com&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;&#x2F;site&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;name&gt;微博&lt;&#x2F;name&gt; &lt;url&gt;www.weibo.com&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;&#x2F;site&gt;</span><br><span class="line">&lt;&#x2F;sites&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>YAML:</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sites:</span><br><span class="line">   -</span><br><span class="line">       name:菜鸟教程</span><br><span class="line">       url:www.runoob.com</span><br><span class="line">   -</span><br><span class="line">       name:google</span><br><span class="line">       url:www.google.com</span><br><span class="line">   -  </span><br><span class="line">       name:微博</span><br><span class="line">       url:www.weibo.com</span><br></pre></td></tr></table></figure>

<p>2.JSON 与 XML 的相同之处：</p>
<ul>
<li>JSON 和 XML 数据都是 “自我描述” ，都易于理解。</li>
<li>JSON 和 XML 数据都是有层次的结构</li>
<li>JSON 和 XML 数据可以被大多数编程语言使用</li>
<li></li>
</ul>
<p>JSON 与 XML 的不同之处：</p>
<ul>
<li>JSON 不需要结束标签</li>
<li>JSON 更加简短</li>
<li>JSON 读写速度更快</li>
<li>JSON 可以使用数组</li>
</ul>
<blockquote>
<p><strong>最大的不同是</strong>：XML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析。</p>
<ul>
<li><a href="https://www.runoob.com/js/javascript-json-parse.html">JSON.parse()</a>: 将一个 JSON 字符串转换为 JavaScript 对象。</li>
<li><a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify()</a>: 于将 JavaScript 值转换为 JSON 字符串。</li>
</ul>
</blockquote>
<h4 id="为什么-JSON-比-XML-更好？"><a href="#为什么-JSON-比-XML-更好？" class="headerlink" title="为什么 JSON 比 XML 更好？"></a>为什么 JSON 比 XML 更好？</h4><p>XML 比 JSON 更难解析。</p>
<p>JSON 可以直接使用现有的 JavaScript 对象解析。</p>
<p>针对 AJAX 应用，JSON 比 XML 数据加载更快，而且更简单：</p>
<p>使用 XML</p>
<ul>
<li>获取 XML 文档</li>
<li>使用 XML DOM 迭代循环文档</li>
<li>接数据解析出来复制给变量</li>
</ul>
<p>使用 JSON</p>
<ul>
<li>获取 JSON 字符串</li>
<li>JSON.Parse 解析 JSON 字符串</li>
</ul>
<h3 id="3-YAML使用场景"><a href="#3-YAML使用场景" class="headerlink" title="3.YAML使用场景"></a>3.YAML使用场景</h3><p>对于序列化语言来说，使用场景如下：</p>
<ul>
<li>与服务器之间传输数据</li>
<li>使用一个配置文件来配置应用，这些文件声明对应参数和相应取值</li>
<li>在同一个应用不同组件之间转换数据</li>
<li>中间数据存储 针对此类场景，YAML有一些明确的优势相比于其他同类语言。也是为什么现在越来越多的开发者使用其的地方。</li>
</ul>
<h4 id="YAML的优势"><a href="#YAML的优势" class="headerlink" title="YAML的优势"></a>YAML的优势</h4><ul>
<li>YAML中没有额外的定界符，所以相比JSON或者XML更轻量级。</li>
<li>没有额外定界符，所以更易读(这里持原作者和译者都持保留观点，不少开发者认为有定界符的可读性更强。)</li>
<li>YAML使数据更易于理解，因此常用于配置文件中(观点同上)</li>
<li>应用比价哦广泛，除配置文件之外，传输数据和中间存储都有实践。</li>
<li>YAML是JSON 的超集，对于合法的JSON代码，同样可以被YAML解析，这样对于使用JSON和YAML的应用来说，可以使用一个解析器完成两种解析。 然而其并没有如期望中那样受欢迎，具体而言，因为不同的序列化语言都有其特定的适宜语言或者场景（下文可以提到），并且YAML有一些不足相较于其他广泛使用的序列化语言。</li>
</ul>
<h4 id="YAML的不足"><a href="#YAML的不足" class="headerlink" title="YAML的不足"></a>YAML的不足</h4><ul>
<li>相对年轻，早期很多应用已经使用JONS或者XML来构建，对于开发者来说迁移至YAML成本是十分高的。 举例，假如我们负责的项目是使用XML的，就算我们开发独立的插件也会倾向于XML以便更加契合。</li>
<li>流行广泛程度反向作用域生态系统，例如XML 有着比YAML极为成熟的生态。JSON从2000年开始出现，同样被高度采用。因此在YAML上可以找到对JSON的支持(译者注：既有向现实妥协的味道，也是聪明的做法)</li>
<li>YAML中有很多方式来体系化数据层级，因此处理时会相对复杂些。性能上相对于XML和JSON会有差别。</li>
<li>可能一些开发人员发现很难使用其复杂的缩进格式</li>
</ul>
<h1 id="变量提升练习"><a href="#变量提升练习" class="headerlink" title="变量提升练习"></a>变量提升练习</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;下面题目输出结果</span><br><span class="line">var a &#x3D; 2;</span><br><span class="line">function a()&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof a);</span><br></pre></td></tr></table></figure>

<p>//number</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>web中单页面应用与多页面应用的区别</title>
    <url>/2020/10/28/kuku_class_homework_dayao/class2_homework/class2-web%E4%B8%AD%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E4%B8%8E%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="web中单页面应用与多页面应用的区别"><a href="#web中单页面应用与多页面应用的区别" class="headerlink" title="web中单页面应用与多页面应用的区别"></a>web中单页面应用与多页面应用的区别</h1><table>
<thead>
<tr>
<th></th>
<th>单页面应用（SinglePage Web Application，SPA）</th>
<th>多页面应用（MultiPage Application，MPA）</th>
</tr>
</thead>
<tbody><tr>
<td>组成</td>
<td>一个外壳页面和多个页面片段组成</td>
<td>多个完整页面构成</td>
</tr>
<tr>
<td>资源共用(css,js)</td>
<td>共用，只需在外壳部分加载</td>
<td>不共用，每个页面都需要加载</td>
</tr>
<tr>
<td>刷新方式</td>
<td>页面局部刷新或更改</td>
<td>整页刷新</td>
</tr>
<tr>
<td>url 模式</td>
<td>a.com/#/pageone a.com/#/pagetwo</td>
<td>a.com/pageone.html a.com/pagetwo.html</td>
</tr>
<tr>
<td>用户体验</td>
<td>页面片段间的切换快，用户体验良好</td>
<td>页面切换加载缓慢，流畅度不够，用户体验比较差</td>
</tr>
<tr>
<td>转场动画</td>
<td>容易实现</td>
<td>无法实现</td>
</tr>
<tr>
<td>数据传递</td>
<td>容易</td>
<td>依赖 url传参、或者cookie 、localStorage等</td>
</tr>
<tr>
<td>搜索引擎优化(SEO)</td>
<td>需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化</td>
<td>实现方法简易</td>
</tr>
<tr>
<td>试用范围</td>
<td>高要求的体验度、追求界面流畅的应用</td>
<td>适用于追求高度支持搜索引擎的应用</td>
</tr>
<tr>
<td>开发成本</td>
<td>较高，常需借助专业的框架</td>
<td>较低 ，但页面重复代码多</td>
</tr>
<tr>
<td>维护成本</td>
<td>相对容易</td>
<td>相对复杂</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript的模块化方式</title>
    <url>/2020/10/28/kuku_class_homework_dayao/class2_homework/class2-Javascript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD"><a href="#Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD" class="headerlink" title="Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD"></a>Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD</h1><h2 id="JavaScript-模块化方案"><a href="#JavaScript-模块化方案" class="headerlink" title="JavaScript 模块化方案"></a>JavaScript 模块化方案</h2><p> 模块化这个话题在 ES6 之前是不存在的，因此这也被诟病为早期 JavaScript 开发<strong>全局污染</strong>和<strong>依赖管理混乱</strong>问题的源头。这类历史渊源和发展概述在本文将不会提及，因此感兴趣可以自行搜索 JavaScript 发展史进行了解。</p>
<p>直接进入正题，我们来看看常见的模块化方案都有哪些以及他们都有哪些内容。</p>
<h2 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h2><p> CommonJS 的一个模块就是一个脚本文件，通过执行该文件来加载模块。CommonJS 规范规定，每个模块内部，<code>module</code> 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 <code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的 <code>module.exports</code> 属性。</p>
<p> 我们见过这样的模块引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myModule &#x3D; require(&#39;module&#39;);</span><br><span class="line">myModule.sayHello();</span><br></pre></td></tr></table></figure>

<p> 这是因为我们把模块的方法定义在了模块的属性上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; module.js</span><br><span class="line">module.exports.sayHello &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;Hello &#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果这样写</span><br><span class="line">module.exports &#x3D; sayHello;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用则需要改为</span><br><span class="line">var sayHello &#x3D; require(&#39;module&#39;);</span><br><span class="line">sayHello();</span><br></pre></td></tr></table></figure>

<p> <code>require</code> 命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成一个对象（模块可以多次加载，但是在第一次加载时才会运行，结果被缓存），这个结果长成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: &#39;...&#39;,</span><br><span class="line">  exports: &#123; ... &#125;,</span><br><span class="line">  loaded: true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Node.js 的模块机制实现就是参照了 CommonJS 的标准。但是 Node.js 额外做了一件事，即为每个模块提供了一个 exports 变量，以指向 module.exports，这相当于在每个模块最开始，写有这么一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exports &#x3D; module.exports;</span><br></pre></td></tr></table></figure>

<p>CommonJS 模块的特点：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>独立性是模块的重要特点就，模块内部最好不与程序的其他部分直接交互。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<h2 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2. AMD"></a>2. AMD</h2><p> CommonJS 规范很好，但是不适用于浏览器环境，于是有了 AMD 和 CMD 两种方案。AMD 全称 Asynchronous Module Definition，即异步模块定义。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。除了和 CommonJS 同步加载方式不同之外，AMD 在模块的定义与引用上也有所不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure>

<p> AMD 的模块引入由 define 方法来定义，在 define API 中：</p>
<ul>
<li>id：模块名称，或者模块加载器请求的指定脚本的名字；</li>
<li>dependencies：是个定义中模块所依赖模块的数组，默认为 [“require”, “exports”, “module”]，举个例子比较好理解，当我们创建一个名为 “alpha” 的模块，使用了require，exports，和名为 “beta” 的模块，需要如下书写（示例1）；</li>
<li>factory：为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例1</span><br><span class="line">define(&quot;alpha&quot;, [&quot;require&quot;, &quot;exports&quot;, &quot;beta&quot;], function (require, exports, beta) &#123;</span><br><span class="line">  exports.verb &#x3D; function() &#123;</span><br><span class="line">    return beta.verb();</span><br><span class="line">    &#x2F;&#x2F; 或者</span><br><span class="line">    return require(&quot;beta&quot;).verb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果模块定义不存在依赖，那么可以直接定义对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">  add: function(x, y)&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而使用时我们依旧通过 require 关键字，它包含两个参数，第一个数组为要加载的模块，第二个参数为回调函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require([module], callback);</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require([&#39;math&#39;], function (math) &#123;</span><br><span class="line">  math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h2><p>CMD 全称为 Common Module Definition，是 Sea.js 所推广的一个模块化方案的输出。在 CMD define 的入参中，虽然也支持包含 id, deps 以及 factory 三个参数的形式，但推荐的是接受 factory 一个入参，然后在入参执行时，填入三个参数 require、exports 和 module：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var a &#x3D; require(&#39;.&#x2F;a&#39;);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  var b &#x3D; require(&#39;.&#x2F;b&#39;); </span><br><span class="line">  b.doSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过执行该构造方法，可以得到模块向外提供的接口。在与 AMD 比较上存在两个主要的不同点（来自玉伯<a href="https://www.zhihu.com/question/20351507">回答</a>）：</p>
<ol>
<li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li>
<li>CMD 推崇依赖就近，AMD 推崇依赖前置。</li>
</ol>
<p>如果说的不清楚，那么我们直接看上面的代码用 AMD 该怎么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define([&#39;.&#x2F;a&#39;, &#39;.&#x2F;b&#39;], function(a, b) &#123;  </span><br><span class="line">  a.doSomething();</span><br><span class="line">  b.doSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-UMD"><a href="#4-UMD" class="headerlink" title="4.UMD"></a>4.UMD</h2><p>UMD，全称 Universal Module Definition，即通用模块规范。既然 CommonJs 和 AMD 风格一样流行，那么需要一个可以统一浏览器端以及非浏览器端的模块化方案的规范。</p>
<p>直接来看看官方给出的 jQuery 模块如何用 UMD 定义的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function (factory) &#123;</span><br><span class="line">    if (typeof define &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; define.amd) &#123;</span><br><span class="line">        &#x2F;&#x2F; AMD. Register as an anonymous module.</span><br><span class="line">        define([&#39;jquery&#39;], factory);</span><br><span class="line">    &#125; else if (typeof module &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; module.exports) &#123;</span><br><span class="line">        &#x2F;&#x2F; Node&#x2F;CommonJS</span><br><span class="line">        module.exports &#x3D; function( root, jQuery ) &#123;</span><br><span class="line">            if ( jQuery &#x3D;&#x3D;&#x3D; undefined ) &#123;</span><br><span class="line">                &#x2F;&#x2F; require(&#39;jQuery&#39;) returns a factory that requires window to</span><br><span class="line">                &#x2F;&#x2F; build a jQuery instance, we normalize how we use modules</span><br><span class="line">                &#x2F;&#x2F; that require this pattern but the window provided is a noop</span><br><span class="line">                &#x2F;&#x2F; if it&#39;s defined (how jquery works)</span><br><span class="line">                if ( typeof window !&#x3D;&#x3D; &#39;undefined&#39; ) &#123;</span><br><span class="line">                    jQuery &#x3D; require(&#39;jquery&#39;);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    jQuery &#x3D; require(&#39;jquery&#39;)(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            factory(jQuery);</span><br><span class="line">            return jQuery;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Browser globals</span><br><span class="line">        factory(jQuery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(function ($) &#123;</span><br><span class="line">    $.fn.jqueryPlugin &#x3D; function () &#123; return true; &#125;;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>UMD的实现很简单：</p>
<ul>
<li>先判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块；</li>
<li>再判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式；</li>
<li>前两个都不存在，则将模块公开到全局（window 或 global）；</li>
</ul>
<h2 id="5-ES-Modules"><a href="#5-ES-Modules" class="headerlink" title="5. ES Modules"></a>5. ES Modules</h2><p>当然，以上说的种种都是社区提供的方案，历史上，JavaScript 一直没有模块系统，直到 ES6 在语言标准的层面上，实现了它。其设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。而 ES Modules 不是对象，而是通过 <code>export</code> 命令显式指定输出的代码。</p>
<p>ES Modules 的模块化能力由 <code>export</code> 和 <code>import</code> 组成，<code>export</code> 命令用于规定模块的对外接口，<code>import</code> 命令用于输入其他模块提供的功能。我们可以这样定义一个模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一种方式</span><br><span class="line">export var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">export var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">export var year &#x3D; 1958;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二种方式</span><br><span class="line">var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">var year &#x3D; 1958;</span><br><span class="line"></span><br><span class="line">export &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure>

<p>然后再这样引入他们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; firstName, lastName, year &#125; from &#39;module&#39;;</span><br><span class="line">import &#123; firstName as newName &#125; from &#39;module&#39;;</span><br><span class="line">import * as moduleA from &#39;module&#39;;</span><br></pre></td></tr></table></figure>

<p>除以上两种命令外，还有一个 <code>export default</code> 命令用于指定模块的默认输出（一个模块只能有一个默认输出）。如果使用了 <code>export default</code> 语法，在 import 时则可以任意命名。由于 <code>export default</code> 命令的本质是将后面的值，赋给 <code>default</code> 变量，所以也可以直接将一个值写在 <code>export default</code> 之后。当然，引用方式也存在多种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; default as foo &#125; from &#39;module&#39;;</span><br><span class="line">import foo from &#39;module&#39;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是 Modules 会自动采用严格模式，且 import 命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>陕西·西安</title>
    <url>/2020/10/28/travel/travel/</url>
    <content><![CDATA[<h1 id="陕西·西安"><a href="#陕西·西安" class="headerlink" title="陕西·西安"></a>陕西·西安</h1>]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用手册</title>
    <url>/2020/10/27/kuku_class_homework_dayao/class3_homework/hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="一、hexo使用手册"><a href="#一、hexo使用手册" class="headerlink" title="一、hexo使用手册"></a>一、hexo使用手册</h3><p>Hexo 是一个快速、简洁且高效的博客框架。</p>
<h4 id="1-基础环境需求"><a href="#1-基础环境需求" class="headerlink" title="1.基础环境需求"></a>1.基础环境需求</h4><p>Node.js（Node.js版本&gt;=10.13）</p>
<p>Git</p>
<h4 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h4><p>使用npm安装hexo，可以全局安装也可以局部安装，这里演示的是全局安装。</p>
<p><code>npm install -g hexo-cli</code></p>
<h4 id="3-建站"><a href="#3-建站" class="headerlink" title="3.建站"></a>3.建站</h4><p><strong>初始化hexo框架，并安装相关依赖。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>hexo项目结构如下：</p>
<p>![image-20201027111226805](/Users/dayao/Library/Application Support/typora-user-images/image-20201027111226805.png)</p>
<p><strong>_config.yml</strong><br>网站的配置文件，可在此配置大部分的参数，比如配置网站信息、网址信息、目录结构存放路径、文章新建内容的设定、分类和标签、日期和时间格式（hexo使用moment.js来解析和显示时间）、分页（每页显示文章数）、主题配置等。</p>
<p>详情见：<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p>
<p>例：网站信息配置</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。支援多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<p><strong>package.json</strong><br>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
<p><strong>scaffolds</strong><br>模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p><strong>source</strong><br>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<p><strong>themes</strong><br>主题 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h4 id="3-命令"><a href="#3-命令" class="headerlink" title="3.命令"></a>3.命令</h4><p><strong>a.init</strong></p>
<p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure>

<p><strong>b.new</strong></p>
<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--path</code></td>
<td align="left">自定义新文章的路径</td>
</tr>
<tr>
<td align="left"><code>-r</code>, <code>--replace</code></td>
<td align="left">如果存在同名文章，将其替换</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--slug</code></td>
<td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
<p><strong>c.generate</strong></p>
<p>生成静态文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">or</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-g</code>, <code>--generate</code></td>
<td align="left">部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p><strong>d.publish</strong></p>
<p>发表草稿。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p><strong>e.server</strong></p>
<p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 <a href="https://github.com/hexojs/hexo-server">hexo-server</a> 才能使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，输入以下命令以启动服务器，您的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--port</code></td>
<td align="left">重设端口</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--static</code></td>
<td align="left">静态模式，服务器只处理 <code>public</code> 文件夹内的文件，而不会处理文件变动，在执行时，应先执行 <code>hexo generate</code>，此模式通常用于生产环境（production mode）下</td>
</tr>
<tr>
<td align="left"><code>-l</code>, <code>--log</code></td>
<td align="left">启动日记记录，使用覆盖记录格式</td>
</tr>
<tr>
<td align="left">-i</td>
<td align="left">服务器默认运行在 <code>0.0.0.0</code>，您可以覆盖默认的 IP 设置。hexo server -i 192.168.1.1</td>
</tr>
</tbody></table>
<p><strong>f.deploy</strong></p>
<p>部署网站。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">or</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p><strong>g.render</strong></p>
<p>渲染文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o</code>, <code>--output</code></td>
<td align="left">设置输出路径</td>
</tr>
</tbody></table>
<p><strong>h.migrate</strong></p>
<p>从其他博客系统迁移。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p><strong>i.clean</strong></p>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p><strong>j.list</strong></p>
<p>列出网站资料。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p><strong>k.version</strong></p>
<p>显示 Hexo 版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>

<h4 id="4-迁移"><a href="#4-迁移" class="headerlink" title="4.迁移"></a>4.迁移</h4><p>详情见：<a href="https://hexo.io/zh-cn/docs/migration">https://hexo.io/zh-cn/docs/migration</a></p>
<h2 id="二、更换主题"><a href="#二、更换主题" class="headerlink" title="二、更换主题"></a>二、更换主题</h2><p>1.初始化hexo博客框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>2.下载主题</p>
<p>在hexo主题库中的均可以按照要求下载，建议都用git。</p>
<p>使用git下载到站点目录/source/theme，在theme文件夹下会有一个“主题名”的文件夹。</p>
<p>2.修改站点_config.yml的主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: 主题名</span><br></pre></td></tr></table></figure>

<p>3.按照个人需求修改主题目录下的_config.ml文件</p>
<p>这里你可以修改配置与主题相关的一切，比如菜单等。</p>
<p>4.新建page</p>
<p>新建的菜单类page，要放下站点目录的source文件夹下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>layout默认为post，title是标题</p>
<p>新建的文章内容，要放下站点目录的source/_posts文件夹下。</p>
<p><code>hexo new _posts &lt;title&gt;</code></p>
<p>5.开启本地hexo服务测试</p>
<p><code>hero server</code></p>
<p>三、部署到github page</p>
<p>1.安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>修改站点的_congif.yml配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt;</span><br><span class="line">  branch: [branch]</span><br></pre></td></tr></table></figure>

<p>2.上传</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo cl </span><br><span class="line">hexo g </span><br><span class="line">hexo d </span><br></pre></td></tr></table></figure>

<p>3.hexo命令汇总</p>
<p><strong>（1）<code>$ hexo g</code>或<code>$ hexo generate</code></strong><br>该命令执行后在<code>hexo</code>站点根目录下生成一个打包好的静态文件夹</p>
<p><strong>（2）<code>$ hexo clean</code></strong><br> 把（1）中的<code>public</code>文件夹删除</p>
<p><strong>（3）<code>$ hexo s</code>或<code>$ hexo server</code></strong><br> 启动服务预览</p>
<p><strong>（4）<code>$ hexo d</code>或<code>$ hexo deploy</code></strong><br> 部署站点，在本地生成<code>.deploy_git</code>文件夹，并将编译后的文件上传至 GitHub。</p>
<p><strong>（5）<code>$ hexo new [layout] &lt;title&gt;</code></strong><br> 例如：<code>$ hexo new photo “my-first-blog”</code><br> 上述指令执行时，Hexo 会尝试在 scaffolds 中寻找photo.md布局，若找到，则根据该布局新建文章；若未找到或指令中未指定该参数，则使用post.md新建文章。新建文章的名称在_config.yml中配置。</p>
<p><strong>（6）删除文章</strong><br> 只需在本地把<code>source/_posts</code>文件夹下的文章源文件删除后，执行以下命令重新部署即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ hexo clean <span class="comment">// 一定要先 clean，防止灵异事件发生</span></span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2020/10/26/kuku_class_content/10-array_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>数组（array）是按次序排列的一组值。</strong>每个值的位置都有编号（从0开始），整个数组用方括号表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>上面代码中的<code>a</code>、<code>b</code>、<code>c</code>就构成一个数组，两端的方括号是数组的标志。<code>a</code>是0号位置，<code>b</code>是1号位置，<code>c</code>是2号位置。</p>
<p>除了在定义时赋值，数组也可以先定义后赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>任何类型的数据，都可以放入数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// Object &#123;a: 1&#125;</span></span><br><span class="line">arr[<span class="number">1</span>] <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr[<span class="number">2</span>] <span class="comment">// function ()&#123;return true;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面数组<code>arr</code>的3个成员依次是对象、数组、函数。</p>
<p>如果数组的元素还是数组，就形成了多维数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] <span class="comment">// 2</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h2><p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>typeof</code>运算符认为数组的类型就是对象。</p>
<p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(arr)</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。</p>
<p>由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="string">&#x27;0&#x27;</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。</p>
<p>注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1.00</span>] = <span class="number">6</span>;</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值。</p>
<p>上一章说过，对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr<span class="number">.0</span> <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）。</p>
<h2 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h2><p>数组的<code>length</code>属性，返回数组的成员数量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2<sup>32</sup> - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295。</p>
<p>只要是数组，就一定有<code>length</code>属性。该属性是一个动态的值，等于键名中的最大整数加上<code>1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">arr.length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">arr.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">9</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">arr.length <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">1000</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">arr.length <span class="comment">// 1001</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code>。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。</p>
<p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到<code>length</code>设置的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line">arr.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，当数组的<code>length</code>属性设为2（即最大的整数键只能是1）那么整数键2（值为<code>c</code>）就已经不在数组中了，被自动删除了。</p>
<p>清空数组的一个有效方法，就是将<code>length</code>属性设为0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.length = <span class="number">3</span>;</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code>。</p>
<p>如果人为设置<code>length</code>为不合法的值，JavaScript 会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置负值</span></span><br><span class="line">[].length = -<span class="number">1</span></span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组元素个数大于等于2的32次方</span></span><br><span class="line">[].length = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字符串</span></span><br><span class="line">[].length = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;p&#x27;</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2.1</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性。因为，<code>length</code>属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code>。</p>
<p>如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[-<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">arr.length <span class="comment">// 0</span></span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// &quot;a&quot;</span></span><br><span class="line">arr[<span class="number">4294967296</span>] <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，我们为数组<code>arr</code>添加了两个不合法的数字键，结果<code>length</code>属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。</p>
<h2 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h2><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> arr  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串。</p>
<p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">100</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">100</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>。</p>
<h2 id="for…in-循环和数组的遍历"><a href="#for…in-循环和数组的遍历" class="headerlink" title="for…in 循环和数组的遍历"></a>for…in 循环和数组的遍历</h2><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，不推荐使用<code>for...in</code>遍历数组。</p>
<p>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; a.length) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l = a.length;</span><br><span class="line"><span class="keyword">while</span> (l--) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[l]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。</p>
<p>数组的<code>forEach</code>方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line">colors.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(color);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, , <span class="number">1</span>];</span><br><span class="line">a.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，数组的空位不影响<code>length</code>属性。</p>
<p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,];</span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 3</span></span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组最后一个成员后面有一个逗号，这不影响<code>length</code>属性的值，与没有这个逗号时效果一样。</p>
<p>数组的空位是可以读取的，返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line">a.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响。也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。</p>
<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x, i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a)</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x, i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0. undefined</span></span><br><span class="line"><span class="comment">// 1. undefined</span></span><br><span class="line"><span class="comment">// 2. undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a)</span><br><span class="line"><span class="comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</p>
<h2 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h2><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">obj[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">obj.length <span class="comment">// 3</span></span><br><span class="line">obj.push(<span class="string">&#x27;d&#x27;</span>) <span class="comment">// TypeError: obj.push is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错。</p>
<p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">obj.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组。</p>
<p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">arguments</span> &#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = args(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arrayLike[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arrayLike.length <span class="comment">// 2</span></span><br><span class="line">arrayLike <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM元素集</span></span><br><span class="line"><span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;h3&#x27;</span>);</span><br><span class="line">elts.length <span class="comment">// 3</span></span><br><span class="line">elts <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.length <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组。</p>
<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>

<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span> (<span class="params">elem, i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + <span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="string">&#x27;abc&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2012/12/arrays.html">Arrays in JavaScript</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2012/06/dense-arrays.html">JavaScript: sparse arrays vs. dense arrays</a></li>
<li>Felix Bohm, <a href="http://net.tutsplus.com/tutorials/javascript-ajax/what-they-didnt-tell-you-about-es5s-array-extras/">What They Didn’t Tell You About ES5′s Array Extras</a></li>
<li>Juriy Zaytsev, <a href="http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/">How ECMAScript 5 still does not allow to subclass an array</a></li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2020/10/26/kuku_class_content/9-function_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>函数是一段可以反复调用的代码块。</strong>函数还能接受输入的参数，不同的参数会返回不同的值。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p><strong>JavaScript 有三种声明函数的方法：function 命令、函数表达式、Function 构造函数。</strong></p>
<p><strong>（1）function 命令</strong></p>
<p><code>function</code>命令声明的代码区块，就是一个函数。<code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码命名了一个<code>print</code>函数，以后使用<code>print()</code>这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。</p>
<p><strong>（2）函数表达式</strong></p>
<p>除了用<code>function</code>命令声明函数，还可以采用变量赋值的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法将一个匿名函数赋值给变量。这时，这个<strong>匿名函数又称函数表达式（Function Expression）</strong>，因为赋值语句的等号右侧只能放表达式。</p>
<p>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"><span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>上面代码在函数表达式中，加入了函数名<code>x</code>。这个<code>x</code>只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>函数的表达式需要在语句的结尾加上分号，表示语句结束。</strong>而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。</p>
<p><strong>（3）Function 构造函数</strong></p>
<p>第三种声明函数的方式是<code>Function</code>构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">  <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;return x + y&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Function</code>构造函数接受三个参数，除了最后一个参数是<code>add</code>函数的“函数体”，其他参数都是<code>add</code>函数的参数。</p>
<p>你<strong>可以传递任意数量的参数给<code>Function</code>构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">  <span class="string">&#x27;return &quot;hello world&quot;;&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Function</code>构造函数可以不使用<code>new</code>命令，返回结果完全一样。</p>
<p>总的来说，这种声明函数的方式非常不直观，几乎无人使用。</p>
<h3 id="函数的重复声明"><a href="#函数的重复声明" class="headerlink" title="函数的重复声明"></a>函数的重复声明</h3><p><strong>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，后一次的函数声明覆盖了前面一次。<strong>而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，</strong>这一点要特别注意。</p>
<h3 id="圆括号运算符，return-语句和递归"><a href="#圆括号运算符，return-语句和递归" class="headerlink" title="圆括号运算符，return 语句和递归"></a>圆括号运算符，return 语句和递归</h3><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。</p>
<p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。**<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code>**。</p>
<p>函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> fib(num - <span class="number">2</span>) + fib(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(<span class="number">6</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>fib</code>函数内部又调用了<code>fib</code>，计算得到斐波那契数列的第6个元素是8。</p>
<h3 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h3><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。<strong>函数只是一个可以执行的值，此外并无特殊之处。</strong></p>
<p>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> operator = add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数作为参数和返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">op</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line">a(add)(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h3><p>JavaScript 引擎将函数名视同变量名，所以<strong>采用<code>function</code>命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。</strong>所以，下面的代码不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>表面上，上面代码好像在声明之前就调用了函数<code>f</code>。但是实际上，由于“变量提升”，函数<code>f</code>被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f();</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面的代码等同于下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f;</span><br><span class="line">f();</span><br><span class="line">f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码第二行，调用<code>f</code>的时候，<code>f</code>只是被声明了，还没有被赋值，等于<code>undefined</code>，所以会报错。</p>
<p>注意，如果像下面例子那样，采用<code>function</code>命令和<code>var</code>赋值语句声明同一个函数，由于存在函数提升，最后会采用<code>var</code>赋值语句的定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，表面上后面声明的函数<code>f</code>，应该覆盖前面的<code>var</code>赋值语句，但是由于存在函数提升，实际上正好反过来。</p>
<h2 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h2><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><p>函数的<code>name</code>属性返回函数的名字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f1.name <span class="comment">// &quot;f1&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果是通过变量赋值定义的函数，那么<code>name</code>属性返回变量名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f2.name <span class="comment">// &quot;f2&quot;</span></span><br></pre></td></tr></table></figure>

<p>但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么<code>name</code>属性返回<code>function</code>关键字之后的那个函数名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f3 = <span class="function"><span class="keyword">function</span> <span class="title">myName</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f3.name <span class="comment">// &#x27;myName&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f3.name</code>返回函数表达式的名字。注意，真正的函数名还是<code>f3</code>，而<code>myName</code>这个名字只在函数体内部可用。</p>
<p><code>name</code>属性的一个用处，就是获取参数函数的名字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(myFunc) <span class="comment">// myFunc</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>test</code>内部通过<code>name</code>属性，就可以知道传入的参数是什么函数。</p>
<h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p>函数的<code>length</code>属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line">f.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了空函数<code>f</code>，它的<code>length</code>属性就是定义时的参数个数。不管调用时输入了多少个参数，<code>length</code>属性始终等于2。</p>
<p><code>length</code>属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>函数的<code>toString()</code>方法返回一个字符串，内容是函数的源码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a();</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line"><span class="comment">// function f() &#123;</span></span><br><span class="line"><span class="comment">//  a();</span></span><br><span class="line"><span class="comment">//  b();</span></span><br><span class="line"><span class="comment">//  c();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>对于那些原生的函数，<code>toString()</code>方法返回<code>function ()&#123;[native code]&#125;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt.toString()</span><br><span class="line"><span class="comment">// &quot;function sqrt() &#123; [native code] &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Math.sqrt()</code>是 JavaScript 引擎提供的原生函数，<code>toString()</code>方法就返回原生代码的提示。</p>
<p>函数内部的注释也可以返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line"><span class="comment">// &quot;function f()&#123;/*</span></span><br><span class="line"><span class="comment">//   这是一个</span></span><br><span class="line"><span class="comment">//   多行注释</span></span><br><span class="line"><span class="comment">// */&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>利用这一点，可以变相实现多行字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> multiline = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = fn.toString().split(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> arr.slice(<span class="number">1</span>, arr.length - <span class="number">1</span>).join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line"></span><br><span class="line">multiline(f);</span><br><span class="line"><span class="comment">// &quot; 这是一个</span></span><br><span class="line"><span class="comment">//   多行注释&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，<strong>JavaScript 只有两种作用域</strong>：<strong>一种是全局作用域</strong>，变量在整个程序中一直存在，所有地方都可以读取；<strong>另一种是函数作用域</strong>，变量只在函数内部存在。<strong>ES6 又新增了块级作用域</strong>，本教程不涉及。</p>
<p>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面的代码表明，函数<code>f</code>内部可以读取全局变量<code>v</code>。</p>
<p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v <span class="comment">// ReferenceError: v is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>v</code>在函数内部定义，所以是一个局部变量，函数之外就无法读取。</p>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 2</span></span><br><span class="line">v <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>v</code>同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量<code>v</code>覆盖了全局变量<code>v</code>。</p>
<p>注意，对于<code>var</code>命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>x</code>在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。</p>
<h3 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h3><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。**<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。**</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h3><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>。</p>
<p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>
<p>很容易犯错的一点是，如果函数<code>A</code>调用函数<code>B</code>，却没考虑到函数<code>B</code>不会引用函数<code>A</code>的内部变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y(x)</span><br><span class="line"><span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面代码将函数<code>x</code>作为参数，传入函数<code>y</code>。但是，函数<code>x</code>是在函数<code>y</code>体外声明的，作用域绑定外层，因此找不到函数<code>y</code>的内部变量<code>a</code>，导致报错。</p>
<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了下文要讲解的“闭包”现象。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line">square(<span class="number">3</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>上式的<code>x</code>就是<code>square</code>函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。</p>
<h3 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h3><p>函数参数不是必需的，JavaScript 允许省略参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 1</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">f.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码的函数<code>f</code>定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为<code>undefined</code>。需要注意的是，函数的<code>length</code>属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</p>
<p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f( , <span class="number">1</span>) <span class="comment">// SyntaxError: Unexpected token ,(…)</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果省略第一个参数，就会报错。</p>
<h3 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h3><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  p = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(p);</span><br><span class="line"></span><br><span class="line">p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递。因此，在函数内部，<code>p</code>的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。</p>
<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.p = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，传入函数<code>f</code>的是参数对象<code>obj</code>的地址。因此，在函数内部修改<code>obj</code>的属性<code>p</code>，会影响到原始值。</p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，在函数<code>f()</code>内部，参数对象<code>obj</code>被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响。</p>
<h3 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h3><p>如果有同名的参数，则取最后出现的那个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f()</code>有两个参数，且参数名都是<code>a</code>。取值的时候，以后面的<code>a</code>为准，即使后面的<code>a</code>没有值或被省略，也是以其为准。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>调用函数<code>f()</code>的时候，没有提供第二个参数，<code>a</code>的取值就变成了<code>undefined</code>。这时，如果要获得第一个<code>a</code>的值，可以使用<code>arguments</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h3><p><strong>（1）定义</strong></p>
<p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来。</p>
<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">one</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>。</p>
<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>; <span class="comment">// 开启严格模式</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>。</p>
<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">f() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）与数组的关系</strong></p>
<p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p>
<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">  args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）callee 属性</strong></p>
<p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>
<h2 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<p>理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f1</code>可以读取全局变量<code>n</code>。</p>
<p>但是，正常情况下，函数外部无法读取函数内部声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: n is not defined(</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f1</code>内部声明的变量<code>n</code>，函数外是无法读取的。</p>
<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们不就可以在<code>f1</code>外部读取它的内部变量了吗！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了。</p>
<p>闭包就是函数<code>f2</code>，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把<strong>闭包简单理解成“定义在一个函数内部的函数”</strong>。<strong>闭包最大的特点，就是它可以“记住”诞生的环境</strong>，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量。在本质上，闭包<strong>就是将函数内部和函数外部连接起来的一座桥梁。</strong></p>
<p><strong>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</strong>请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>
<p>为什么会这样呢？原因就在于<code>inc</code>始终在内存中，而<code>inc</code>的存在依赖于<code>createIncrementor</code>，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p>
<p><strong>闭包的另一个用处，是封装对象的私有属性和私有方法。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge</code>和<code>setAge</code>，变成了返回对象<code>p1</code>的私有变量。</p>
<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<h3 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h3><p>根据 JavaScript 的语法，圆括号<code>()</code>跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print</code>函数。</p>
<p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure>

<p>产生这个错误的原因是，<code>function</code>这个关键字即可以当作语句，也可以当作表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当作表达式时，函数可以定义后直接加圆括号调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>&#125;();</span><br><span class="line">f <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，函数定义后直接加圆括号调用，没有报错。原因就是<code>function</code>作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错。</p>
<p>为了避免解析的歧义，JavaScript 规定，如果<code>function</code>关键字出现在行首，一律解释成语句。因此，引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p>
<p>函数定义后立即调用的解决方法，就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure>

<p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表达式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。</p>
<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br></pre></td></tr></table></figure>

<p>上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。</p>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>

<p>甚至像下面这样写，也是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>

<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> tmp = newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p>
<h2 id="eval-命令"><a href="#eval-命令" class="headerlink" title="eval 命令"></a>eval 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var a = 1;&#x27;</span>);</span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码将字符串当作语句运行，生成了变量<code>a</code>。</p>
<p>如果参数字符串无法当作语句运行，那么就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;3x&#x27;</span>) <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用。举例来说，下面的代码将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;return;&#x27;</span>); <span class="comment">// Uncaught SyntaxError: Illegal return statement</span></span><br></pre></td></tr></table></figure>

<p>上面代码会报错，因为<code>return</code>不能单独使用，必须在函数中使用。</p>
<p>如果<code>eval</code>的参数不是字符串，那么会原样返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;a = 2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>eval</code>命令修改了外部变量<code>a</code>的值。由于这个原因，<code>eval</code>有安全风险。</p>
<p>为了防止这种风险，JavaScript 规定，如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&#x27;var foo = 123&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(foo);  <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>上面代码中，<strong>函数<code>f</code>内部是严格模式</strong>，这时<code>eval</code>内部声明的<code>foo</code>变量，就不会影响到外部。</p>
<p>不过，即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&#x27;foo = 2&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(foo);  <span class="comment">// 2</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>上面代码中，严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在。</p>
<p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法。</p>
<h3 id="eval-的别名调用"><a href="#eval-的别名调用" class="headerlink" title="eval 的别名调用"></a>eval 的别名调用</h3><p>前面说过<code>eval</code>不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是<code>eval</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">eval</span>;</span><br><span class="line">m(<span class="string">&#x27;var x = 1&#x27;</span>);</span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>m</code>是<code>eval</code>的别名。静态代码分析阶段，引擎分辨不出<code>m(&#39;var x = 1&#39;)</code>执行的是<code>eval</code>命令。</p>
<p>为了保证<code>eval</code>的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="built_in">eval</span>;</span><br><span class="line">  e(<span class="string">&#x27;console.log(a)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量。这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。</p>
<p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>.call(<span class="literal">null</span>, <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"><span class="built_in">window</span>.eval(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">(<span class="built_in">eval</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这些形式都是<code>eval</code>的别名调用，作用域都是全局作用域。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Ben Alman, <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression (IIFE)</a></li>
<li>Mark Daggett, <a href="http://markdaggett.com/blog/2013/02/15/functions-explained/">Functions Explained</a></li>
<li>Juriy Zaytsev, <a href="http://kangax.github.com/nfe/">Named function expressions demystified</a></li>
<li>Marco Rogers polotek, <a href="http://docs.nodejitsu.com/articles/javascript-conventions/what-is-the-arguments-object">What is the arguments object?</a></li>
<li>Juriy Zaytsev, <a href="http://perfectionkills.com/global-eval-what-are-the-options/">Global eval. What are the options?</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2014/01/eval.html">Evaluating JavaScript code via eval() and new Function()</a></li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>对象</title>
    <url>/2020/10/26/kuku_class_content/8-object_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。</p>
<p>什么是对象？简单说，<strong>对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  bar: <span class="string">&#x27;World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，大括号就定义了一个对象，它被赋值给变量<code>obj</code>，所以变量<code>obj</code>就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是<code>foo: &#39;Hello&#39;</code>，其中<code>foo</code>是“键名”（成员的名称），字符串<code>Hello</code>是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是<code>bar: &#39;World&#39;</code>，<code>bar</code>是键名，<code>World</code>是键值。两个键值对之间用逗号分隔。</p>
<h3 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h3><p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;bar&#x27;</span>: <span class="string">&#x27;World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果键名是数值，会被自动转为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">3.2</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">1e2</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">1e-2</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">.234</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">0xFF</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   1: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   3.2: &quot;b&quot;,</span></span><br><span class="line"><span class="comment">//   100: true,</span></span><br><span class="line"><span class="comment">//   0.01: true,</span></span><br><span class="line"><span class="comment">//   0.234: true,</span></span><br><span class="line"><span class="comment">//   255: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">obj[<span class="string">&#x27;100&#x27;</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的所有键名虽然看上去像数值，实际上都被自动转成了字符串。</p>
<p><strong>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">1</span>p: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;1p&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;h w&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p+q&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。</p>
<p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。<strong>如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(<span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的属性<code>p</code>，就指向一个函数。</p>
<p>如果属性的值还是一个对象，就形成了链式引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">bar</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.foo = o2;</span><br><span class="line">o1.foo.bar <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>o1</code>的属性<code>foo</code>指向对象<code>o2</code>，就可以链式引用<code>o2</code>的属性。</p>
<p>对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="number">123</span>,</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>m</code>属性后面的那个逗号，有没有都可以。</p>
<p><strong>属性可以动态创建，不必在对象声明时就指定。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.foo = <span class="number">123</span>;</span><br><span class="line">obj.foo <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，直接对<code>obj</code>对象的<code>foo</code>属性赋值，结果就在运行时创建了<code>foo</code>属性。</p>
<h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p><strong>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = <span class="number">1</span>;</span><br><span class="line">o2.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">o2.b = <span class="number">2</span>;</span><br><span class="line">o1.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。</p>
<p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>;</span><br><span class="line">o2 <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象。</p>
<p>但是，<strong>这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">y <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，当<code>x</code>的值发生变化后，<code>y</code>的值并不变，这就表示<code>y</code>和<code>x</code>并不是指向同一个内存地址。</p>
<h3 id="表达式还是语句？"><a href="#表达式还是语句？" class="headerlink" title="表达式还是语句？"></a>表达式还是语句？</h3><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含<code>foo</code>属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签<code>foo</code>，指向表达式<code>123</code>。</p>
<p>为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面的语句是一个代码块，而且只有解释为代码块，才能执行。</p>
<p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;) <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>这种差异在<code>eval</code>语句（作用是对字符串求值）中反映得最明显。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;&#123;foo: 123&#125;&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;(&#123;foo: 123&#125;)&#x27;</span>) <span class="comment">// &#123;foo: 123&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果没有圆括号，<code>eval</code>将其理解为一个代码块；加上圆括号以后，就理解成一个对象。</p>
<h2 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h2><h3 id="属性的读取"><a href="#属性的读取" class="headerlink" title="属性的读取"></a>属性的读取</h3><p><strong>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj[<span class="string">&#x27;p&#x27;</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码分别采用点运算符和方括号运算符，读取属性<code>p</code>。</p>
<p>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo  <span class="comment">// 1</span></span><br><span class="line">obj[foo]  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，引用对象<code>obj</code>的<code>foo</code>属性时，如果使用点运算符，<code>foo</code>就是字符串；如果使用方括号运算符，但是不使用引号，那么<code>foo</code>就是一个变量，指向字符串<code>bar</code>。</p>
<p>方括号运算符内部还可以使用表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj[<span class="string">&#x27;hello&#x27;</span> + <span class="string">&#x27; world&#x27;</span>]</span><br><span class="line">obj[<span class="number">3</span> + <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>数字键可以不加引号，因为会自动转成字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0.7</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">&#x27;0.7&#x27;</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj[<span class="number">0.7</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的数字键<code>0.7</code>，加不加引号都可以，因为会被自动转为字符串。</p>
<p>注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">123</span>: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj<span class="number">.123</span> <span class="comment">// 报错</span></span><br><span class="line">obj[<span class="number">123</span>] <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的第一个表达式，对数值键名<code>123</code>使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。</p>
<h3 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h3><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[<span class="string">&#x27;bar&#x27;</span>] = <span class="string">&#x27;World&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，分别使用点运算符和方括号运算符，对属性赋值。</p>
<p>JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.p = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h3><p><strong>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  key1: <span class="number">1</span>,</span><br><span class="line">  key2: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// [&#x27;key1&#x27;, &#x27;key2&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="属性的删除：delete-命令"><a href="#属性的删除：delete-命令" class="headerlink" title="属性的删除：delete 命令"></a>属性的删除：delete 命令</h3><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// [&quot;p&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性。</p>
<p>注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code>。因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的。</p>
<p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>（关于<code>Object.defineProperty</code>方法的介绍，请看《标准库》的 Object 对象一章）。</p>
<p>另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》章节）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p>
<h3 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a>属性是否存在：in 运算符</h3><p><strong><code>in</code>运算符用于检查对象是否包含某个属性</strong>（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的。</p>
<p>这时，可以使用对象的**<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。**</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性的遍历：for…in-循环"><a href="#属性的遍历：for…in-循环" class="headerlink" title="属性的遍历：for…in 循环"></a>属性的遍历：for…in 循环</h3><p><code>for...in</code>循环用来遍历一个对象的全部属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;键名：&#x27;</span>, i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;键值：&#x27;</span>, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 键名： a</span></span><br><span class="line"><span class="comment">// 键值： 1</span></span><br><span class="line"><span class="comment">// 键名： b</span></span><br><span class="line"><span class="comment">// 键值： 2</span></span><br><span class="line"><span class="comment">// 键名： c</span></span><br><span class="line"><span class="comment">// 键值： 3</span></span><br></pre></td></tr></table></figure>

<p><code>for...in</code>循环有两个使用注意点。</p>
<ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
</ul>
<p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString 属性是存在的</span></span><br><span class="line">obj.toString <span class="comment">// toString() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125; <span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。</p>
<p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;老张&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br></pre></td></tr></table></figure>

<h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><p><code>with</code>语句的格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">1</span>,</span><br><span class="line">  p2: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">obj.p1 = <span class="number">4</span>;</span><br><span class="line">obj.p2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">with</span> (<span class="built_in">document</span>.links[<span class="number">0</span>])&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(href);</span><br><span class="line">  <span class="built_in">console</span>.log(title);</span><br><span class="line">  <span class="built_in">console</span>.log(style);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].href);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].title);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].style);</span><br></pre></td></tr></table></figure>

<p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.p1 <span class="comment">// undefined</span></span><br><span class="line">p1 <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code>。正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它。</p>
<p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">obj1.obj2.obj3</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.obj2.obj3;</span><br><span class="line"><span class="built_in">console</span>.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对象：如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p>
<p>原始数据：number、string、boolean</p>
<p>如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。他们并没有指向同一个内存地址，修改其中一个值，不会影响另一个值。</p>
<p>对象属性赋值：点运算符和方括号运算符，对属性赋值</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Dr. Axel Rauschmayer，<a href="http://www.2ality.com/2012/10/javascript-properties.html">Object properties in JavaScript</a></li>
<li>Lakshan Perera, <a href="http://www.laktek.com/2012/12/29/revisiting-javascript-objects/">Revisiting JavaScript Objects</a></li>
<li>Angus Croll, <a href="http://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/">The Secret Life of JavaScript Primitives</a>i</li>
<li>Dr. Axel Rauschmayer, <a href="http://www.2ality.com/2011/06/with-statement.html">JavaScript’s with statement and why it’s deprecated</a></li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2020/10/26/kuku_class_content/7-string_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;key = &quot;value&quot;&#x27;</span></span><br><span class="line"><span class="string">&quot;It&#x27;s a long journey&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面两个都是合法的字符串。</p>
<p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Did she say \&#x27;Hello\&#x27;?&#x27;</span></span><br><span class="line"><span class="comment">// &quot;Did she say &#x27;Hello&#x27;?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Did she say \&quot;Hello\&quot;?&quot;</span></span><br><span class="line"><span class="comment">// &quot;Did she say &quot;Hello&quot;?&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。</p>
<p>字符串默认只能写在一行内，分成多行将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c&#x27;</span></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></table></figure>

<p>上面代码将一个字符串分成三行，JavaScript 就会报错。</p>
<p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">string&#x27;</span>;</span><br><span class="line"></span><br><span class="line">longString</span><br><span class="line"><span class="comment">// &quot;Long long long string&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</p>
<p>连接运算符（<code>+</code>）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;string&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果想输出多行字符串，有一种利用多行注释的变通方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/*</span></span><br><span class="line"><span class="comment">line 1</span></span><br><span class="line"><span class="comment">line 2</span></span><br><span class="line"><span class="comment">line 3</span></span><br><span class="line"><span class="comment">*/</span>&#125;).toString().split(<span class="string">&#x27;\n&#x27;</span>).slice(<span class="number">1</span>, -<span class="number">1</span>).join(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;line 1</span></span><br><span class="line"><span class="comment">// line 2</span></span><br><span class="line"><span class="comment">// line 3&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，输出的字符串就是多行。</p>
<p><strong>注释：</strong></p>
<p>toString():把数字转换为字符串  </p>
<p>function () { /*<br>line 1<br>line 2<br>line 3<br>*/}</p>
<p>split():把一个字符串分割成字符串数组 //[ ‘ function () { / *’, ‘ line 1 ‘, ‘ line 2 ‘, ‘ line 3 ‘, ‘ */} ‘ ] ,长度为5的数组</p>
<p>slice() :可提取字符串的某个部分，并以新的字符串返回被提取的部分。slice() 方法不会改变原始数组。//[ ‘line 1’, ‘line 2’, ‘line 3’ ]</p>
<p>join():把数组中的所有元素转换一个字符串。 元素是通过指定的分隔符进行分隔的。</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p>
<p>需要用反斜杠转义的特殊字符，主要有下面这些。</p>
<ul>
<li><code>\0</code> ：null（<code>\u0000</code>）</li>
<li><code>\b</code> ：后退键（<code>\u0008</code>）</li>
<li><code>\f</code> ：换页符（<code>\u000C</code>）</li>
<li><code>\n</code> ：换行符（<code>\u000A</code>）</li>
<li><code>\r</code> ：回车键（<code>\u000D</code>）</li>
<li><code>\t</code> ：制表符（<code>\u0009</code>）</li>
<li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li>
<li><code>\&#39;</code> ：单引号（<code>\u0027</code>）</li>
<li><code>\&quot;</code> ：双引号（<code>\u0022</code>）</li>
<li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li>
</ul>
<p>上面这些字符前面加上反斜杠，都表示特殊含义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1\n2&#x27;</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>\n</code>表示换行，输出的时候就分成了两行。</p>
<p>反斜杠还有三种特殊用法。</p>
<p>（1）<code>\HHH</code></p>
<p>反斜杠后面紧跟三个八进制数（<code>000</code>到<code>377</code>），代表一个字符。<code>HHH</code>对应该字符的 Unicode 码点，比如<code>\251</code>表示版权符号。显然，这种方法只能输出256种字符。</p>
<p>（2）<code>\xHH</code></p>
<p><code>\x</code>后面紧跟两个十六进制数（<code>00</code>到<code>FF</code>），代表一个字符。<code>HH</code>对应该字符的 Unicode 码点，比如<code>\xA9</code>表示版权符号。这种方法也只能输出256种字符。</p>
<p>（3）<code>\uXXXX</code></p>
<p><code>\u</code>后面紧跟四个十六进制数（<code>0000</code>到<code>FFFF</code>），代表一个字符。<code>XXXX</code>对应该字符的 Unicode 码点，比如<code>\u00A9</code>表示版权符号。</p>
<p>下面是这三种字符特殊写法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\251&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"><span class="string">&#x27;\xA9&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"><span class="string">&#x27;\u00A9&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\a&#x27;</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。</p>
<p>如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Prev \\ Next&quot;</span></span><br><span class="line"><span class="comment">// &quot;Prev \ Next&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] <span class="comment">// &quot;h&quot;</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line">s[<span class="number">4</span>] <span class="comment">// &quot;o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对字符串使用方括号运算符</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">3</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[-<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s[<span class="number">0</span>];</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">5</span>] = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p>
<h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p><code>length</code>属性返回字符串的长度，该属性也是无法改变的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.length = <span class="number">3</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.length = <span class="number">7</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示字符串的<code>length</code>属性无法改变，但是不会报错。</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p>
<p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 Unicode 码点。比如，<code>\u00A9</code>代表版权符号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;\u00A9&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;©&quot;</span></span><br></pre></td></tr></table></figure>

<p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f\u006F\u006F = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">foo <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一行的变量名<code>foo</code>是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。</p>
<p>我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</p>
<p>但是，UTF-16 有两种长度：对于码点在<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为16位（即2个字节）；对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为32位（即4个字节），而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。举例来说，码点<code>U+1D306</code>对应的字符为<code>𝌆，</code>它写成 UTF-16 就是<code>0xD834 0xDF06</code>。</p>
<p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到<code>U+FFFF</code>，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符<code>𝌆</code>，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;𝌆&#x27;</span>.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，JavaScript 认为<code>𝌆</code>的长度为2，而不是1。</p>
<p>总结一下，对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是两个字符（<code>length</code>属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。</p>
<h2 id="Base64-转码"><a href="#Base64-转码" class="headerlink" title="Base64 转码"></a>Base64 转码</h2><p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p>
<p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p>
<p>JavaScript 原生提供两个 Base64 相关的方法。</p>
<ul>
<li><code>btoa()</code>：任意值转为 Base64 编码</li>
<li><code>atob()</code>：Base64 编码转为原来的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">btoa(string) <span class="comment">// &quot;SGVsbG8gV29ybGQh&quot;</span></span><br><span class="line">atob(<span class="string">&#x27;SGVsbG8gV29ybGQh&#x27;</span>) <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btoa(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span></span><br><span class="line">b64Decode(<span class="string">&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;</span>) <span class="comment">// &quot;你好&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Mathias Bynens, <a href="http://mathiasbynens.be/notes/javascript-encoding">JavaScript’s internal character encoding: UCS-2 or UTF-16?</a></li>
<li>Mathias Bynens, <a href="http://mathiasbynens.be/notes/javascript-unicode">JavaScript has a Unicode problem</a></li>
<li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa">Window.btoa</a></li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>数值</title>
    <url>/2020/10/26/kuku_class_content/6-number_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h3><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。</p>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h3><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p>
<ul>
<li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li>
<li>第2位到第12位（共11位）：指数部分</li>
<li>第13位到第64位（共52位）：小数部分（即有效数字）</li>
</ul>
<p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p>
<p>指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是<code>1.xx...xx</code>的形式，其中<code>xx..xx</code>的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(-1)^符号位 * 1.xx...xx * 2^指数部分</span><br></pre></td></tr></table></figure>

<p>上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。</p>
<p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2<sup>53</sup>到2<sup>53</sup>，都可以精确表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span></span><br><span class="line"><span class="comment">// 9007199254740994</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">3</span></span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">4</span></span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多出的三个有效数字，将无法保存</span></span><br><span class="line"><span class="number">9007199254740992111</span></span><br><span class="line"><span class="comment">// 9007199254740992000</span></span><br></pre></td></tr></table></figure>

<p>上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的<code>111</code>）都会无法保存，变成0。</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。</p>
<p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">1075</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>下面是一个实际的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++</span>)</span> &#123;</span><br><span class="line">  x = x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对<code>0.5</code>连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。</p>
<p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure>

<h2 id="数值的表示法"><a href="#数值的表示法" class="headerlink" title="数值的表示法"></a>数值的表示法</h2><p>JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>（十进制）和<code>0xFF</code>（十六进制）。</p>
<p>数值也可以采用科学计数法表示，下面是几个科学计数法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">123e3</span> <span class="comment">// 123000</span></span><br><span class="line"><span class="number">123e-3</span> <span class="comment">// 0.123</span></span><br><span class="line">-<span class="number">3.1E+12</span></span><br><span class="line"><span class="number">.1e-23</span></span><br></pre></td></tr></table></figure>

<p>科学计数法允许字母<code>e</code>或<code>E</code>的后面，跟着一个整数，表示这个数值的指数部分。</p>
<p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p>
<p><strong>（1）小数点前的数字多于21位。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567890123456789012</span></span><br><span class="line"><span class="comment">// 1.2345678901234568e+21</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789012345678901</span></span><br><span class="line"><span class="comment">// 123456789012345680000</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）小数点后的零多于5个。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小数点后紧跟5个以上的零，</span></span><br><span class="line"><span class="comment">// 就自动转为科学计数法</span></span><br><span class="line"><span class="number">0.0000003</span> <span class="comment">// 3e-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，就保持原来的字面形式</span></span><br><span class="line"><span class="number">0.000003</span> <span class="comment">// 0.000003</span></span><br></pre></td></tr></table></figure>

<h2 id="数值的进制"><a href="#数值的进制" class="headerlink" title="数值的进制"></a>数值的进制</h2><p>使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p>
<ul>
<li>十进制：没有前导0的数值。</li>
<li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li>
<li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li>
<li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li>
</ul>
<p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0xff</span> <span class="comment">// 255</span></span><br><span class="line"><span class="number">0o377</span> <span class="comment">// 255</span></span><br><span class="line"><span class="number">0b11</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>xzz <span class="comment">// 报错</span></span><br><span class="line"><span class="number">0</span>o88 <span class="comment">// 报错</span></span><br><span class="line"><span class="number">0</span>b22 <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，十六进制出现了字母<code>z</code>、八进制出现数字<code>8</code>、二进制出现数字<code>2</code>，因此报错。</p>
<p>通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字<code>8</code>和<code>9</code>，则该数值被视为十进制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>888 <span class="comment">// 888</span></span><br><span class="line"><span class="number">0</span>777 <span class="comment">// 511</span></span><br></pre></td></tr></table></figure>

<p>前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</p>
<h2 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h2><p>JavaScript 提供了几个特殊的数值。</p>
<h3 id="正零和负零"><a href="#正零和负零" class="headerlink" title="正零和负零"></a>正零和负零</h3><p>前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连<code>0</code>也不例外。</p>
<p>JavaScript 内部实际上存在2个<code>0</code>：一个是<code>+0</code>，一个是<code>-0</code>，区别就是64位浮点数表示法的符号位不同。它们是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>几乎所有场合，正零和负零都会被当作正常的<code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">-<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">(-<span class="number">0</span>).toString() <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line">(+<span class="number">0</span>).toString() <span class="comment">// &#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>唯一有区别的场合是，<code>+0</code>或<code>-0</code>当作分母，返回的值是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span> / +<span class="number">0</span>) === (<span class="number">1</span> / -<span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面的代码之所以出现这样结果，是因为除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的（关于<code>Infinity</code>详见下文）。</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p><strong>（1）含义</strong></p>
<p><strong><code>NaN</code>是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="string">&#x27;x&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>上面代码运行时，会自动将字符串<code>x</code>转为数值，但是由于<code>x</code>不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”（<code>NaN</code>）。</p>
<p>另外，一些数学函数的运算结果会出现<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.acos(<span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p><code>0</code>除以<code>0</code>也会得到<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> / <span class="number">0</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>需<strong>要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// &#x27;number&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）运算规则</strong></p>
<p><strong><code>NaN</code>不等于任何值，包括它本身。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p><code>NaN</code>在布尔运算时被当作<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> + <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> - <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> * <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> / <span class="number">32</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><p><strong>（1）含义</strong></p>
<p><strong><code>Infinity</code>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到<code>Infinity</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景一</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景二</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回<code>Infinity</code>。第二个场景是<code>0</code>除以<code>0</code>会得到<code>NaN</code>，而非0数值除以<code>0</code>，会返回<code>Infinity</code>。</p>
<p><code>Infinity</code>有正负之分，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> === -<span class="literal">Infinity</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> / -<span class="number">0</span> <span class="comment">// -Infinity</span></span><br><span class="line">-<span class="number">1</span> / -<span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，非零正数除以<code>-0</code>，会得到<code>-Infinity</code>，负数除以<code>-0</code>，会得到<code>Infinity</code>。</p>
<p><strong>由于数值正向溢出（overflow）、负向溢出（underflow）和被<code>0</code>除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。</strong></p>
<p><strong><code>Infinity</code>大于一切数值（除了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了<code>NaN</code>）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> &gt; <span class="number">1000</span> <span class="comment">// true</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; -<span class="number">1000</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> &lt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）运算规则</strong></p>
<p><strong><code>Infinity</code>的四则运算，符合无穷的数学计算规则。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> - <span class="literal">Infinity</span> <span class="comment">// -Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">5</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>0乘以<code>Infinity</code>，返回<code>NaN</code>；0除以<code>Infinity</code>，返回<code>0</code>；<code>Infinity</code>除以0，返回<code>Infinity</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>加上或乘以<code>Infinity</code>，返回的还是<code>Infinity</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> + <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>减去或除以<code>Infinity</code>，得到<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>与<code>null</code>计算时，<code>null</code>会转成0，等同于与<code>0</code>的计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">null</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p><strong><code>Infinity</code>与<code>undefined</code>计算，返回的都是<code>NaN</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> + <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> - <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> / <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h2><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p><strong>（1）基本用法</strong></p>
<p><strong><code>parseInt</code>方法用于将字符串转为整数。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>如果字符串头部有空格，空格会被自动去除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;   81&#x27;</span>) <span class="comment">// 81</span></span><br></pre></td></tr></table></figure>

<p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1.23&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;8a&#x27;</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12**&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;15e2&#x27;</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;15px&#x27;</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p>
<p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;.3&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;+&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;+1&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>所以，<code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</p>
<p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0x10&#x27;</span>) <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p>如果字符串以<code>0</code>开头，将其按照10进制解析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;011&#x27;</span>) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000.5</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1e+21&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;8e-7&#x27;</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）进制转换</strong></p>
<p><strong><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>) <span class="comment">// 1000</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">10</span>) <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>下面是转换指定进制的数的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">2</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">6</span>) <span class="comment">// 216</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">8</span>) <span class="comment">// 512</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，二进制、六进制、八进制的<code>1000</code>，分别等于十进制的8、216和512。这意味着，可以用<code>parseInt</code>方法进行进制的转换。</p>
<p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code>。如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">37</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">0</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="literal">null</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="literal">undefined</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1546&#x27;</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;546&#x27;</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对于二进制来说，<code>1</code>是有意义的字符，<code>5</code>、<code>4</code>、<code>6</code>都是无意义的字符，所以第一行返回1，第二行返回<code>NaN</code>。</p>
<p>前面说过，如果<code>parseInt</code>的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">36</span>) <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>上面代码中，十六进制的<code>0x11</code>会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串<code>17</code>，最后返回结果<code>43</code>和<code>1</code>。</strong></p>
<p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0</span>11, <span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0</span>11), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">9</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一行的<code>011</code>会被先转为字符串<code>9</code>，因为<code>9</code>不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt(&#39;011&#39;, 2)</code>，<code>011</code>则是会被当作二进制处理，返回3。</p>
<p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个<code>0</code>。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p>
<h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p><strong><code>parseFloat</code>方法用于将一个字符串转为浮点数。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>

<p>如果字符串符合科学计数法，则会进行相应的转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;314e-2&#x27;</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;0.0314E+2&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>

<p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14more non-digit characters&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>

<p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;\t\v\r12.34\n &#x27;</span>) <span class="comment">// 12.34</span></span><br></pre></td></tr></table></figure>

<p><strong>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;FF2&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，尤其值得注意，**<code>parseFloat</code>会将空字符串转为<code>NaN</code>。**</p>
<p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p><strong><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>但是<strong>，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。</strong>比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，**<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。**</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(<span class="string">&#x27;Hello&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(&#123;&#125;)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;xzy&#x27;</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>([<span class="string">&#x27;xzy&#x27;</span>])) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>([]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;123&#x27;</span>]) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值，请参见《数据类型转换》一章。</p>
<p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isNaN</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h3><p><strong><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Dr. Axel Rauschmayer, <a href="http://www.2ality.com/2012/04/number-encoding.html">How numbers are encoded in JavaScript</a></li>
<li>Humphry, <a href="http://blog.segmentfault.com/humphry/1190000000407658">JavaScript 中 Number 的一些表示上/下限</a></li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>null, undefined 和布尔值</title>
    <url>/2020/10/26/kuku_class_content/5-null-undefined-boolean_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="null-undefined-和布尔值"><a href="#null-undefined-和布尔值" class="headerlink" title="null, undefined 和布尔值"></a>null, undefined 和布尔值</h1><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似。将一个变量赋值为<code>undefined</code>或<code>null</code>，老实说，语法效果几乎没区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>a</code>分别被赋值为<code>undefined</code>和<code>null</code>，这两种写法的效果几乎等价。</p>
<p>在<code>if</code>语句中，它们都会被自动转为<code>false</code>，相等运算符（<code>==</code>）甚至直接报告两者相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;undefined is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;null is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有<code>null</code>，没有<code>undefined</code>！</p>
<p>既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。</p>
<p>1995年 JavaScript 诞生时，最初像 Java 一样，只设置了<code>null</code>表示”无”。根据 C 语言的传统，<code>null</code>可以自动转为<code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span> <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>null</code>转为数字时，自动变成0。</p>
<p>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，<code>null</code>就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为0，很不容易发现错误。</p>
<p>因此，他又设计了一个<code>undefined</code>。<strong>区别是这样的：<code>null</code>是一个表示“空”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="用法和含义"><a href="#用法和含义" class="headerlink" title="用法和含义"></a>用法和含义</h3><p>对于<code>null</code>和<code>undefined</code>，大致可以像下面这样理解。</p>
<p><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入<code>null</code>，表示未发生错误。</p>
<p><code>undefined</code>表示“未定义”，下面是返回<code>undefined</code>的典型场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量声明了，但没有赋值</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>布尔值代表“真”和“假”两个状态。“真”用关键字<code>true</code>表示，“假”用关键字<code>false</code>表示。布尔值只有这两个值。</p>
<p>下列运算符会返回布尔值：</p>
<ul>
<li>前置逻辑运算符： <code>!</code> (Not)</li>
<li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code></li>
<li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li>
</ul>
<p><strong>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</strong></p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>布尔值往往用于程序流程的控制，请看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>if</code>命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值<code>false</code>，导致程序不会进入代码块，所以没有任何输出。</p>
<p><strong>注意，空数组（<code>[]</code>）和空对象（<code>&#123;&#125;</code>）对应的布尔值，都是<code>true</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (&#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>更多关于数据类型转换的介绍，参见《数据类型转换》一章。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/01/categorizing-values.html">Categorizing values in JavaScript</a></li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型概述</title>
    <url>/2020/10/26/kuku_class_content/4-type-general_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="数据类型概述"><a href="#数据类型概述" class="headerlink" title="数据类型概述"></a>数据类型概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本次学习不涉及。）</p>
<ul>
<li>数值（number）：整数和小数（比如<code>1</code>和<code>3.14</code>）</li>
<li>字符串（string）：文本（比如<code>Hello World</code>）。</li>
<li>布尔值（boolean）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）</li>
<li><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li>
<li><code>null</code>：表示空值，即此处的值为空。</li>
<li>对象（object）：各种值组成的集合。</li>
</ul>
<p>通常，<strong>数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值</strong>，即它们是最基本的数据类型，不能再细分了。<strong>对象则称为合成类型（complex type）的值</strong>，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于**<code>undefined</code>和<code>null</code>，一般将它们看成两个特殊值。**</p>
<p>对象是最复杂的数据类型，又可以分成三个子类型。</p>
<ul>
<li>狭义的对象（object）</li>
<li>数组（array）</li>
<li>函数（function）</li>
</ul>
<p>狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本次学习中，涉及的“对象”都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p>
<ul>
<li><code>typeof</code>运算符</li>
<li><code>instanceof</code>运算符</li>
<li><code>Object.prototype.toString</code>方法</li>
</ul>
<p><code>instanceof</code>运算符和<code>Object.prototype.toString</code>方法，将在后文介绍。这里介绍<code>typeof</code>运算符。</p>
<p><code>typeof</code>运算符可以返回一个值的数据类型。</p>
<p>数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;123&#x27;</span> <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// &quot;boolean&quot;</span></span><br></pre></td></tr></table></figure>

<p>函数返回<code>function</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f</span><br><span class="line"><span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>undefined</code>返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<p>利用这一点，<code>typeof</code>可以用来检查一个没有声明的变量，而不报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">v</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> v</span><br><span class="line"><span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<strong>变量<code>v</code>没有用<code>var</code>命令声明，直接使用就会报错。但是，放在<code>typeof</code>后面，就不报错了，而是返回<code>undefined</code>。</strong></p>
<p>实际编程中，这个特点通常用在判断语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>typeof 对象，返回的都是<code>object</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，空数组（<code>[]</code>）的类型也是<code>object</code>，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，**<code>instanceof</code>运算符可以区分数组和对象**。<code>instanceof</code>运算符的详细解释，请见《面向对象编程》一章。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>null</code>返回<code>object</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>null</code>的类型是<code>object</code>，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作<code>object</code>的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/11/improving-typeof.html">Improving the JavaScript typeof operator</a></li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的基本语法</title>
    <url>/2020/10/26/kuku_class_content/3-grammar_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="JavaScript-的基本语法"><a href="#JavaScript-的基本语法" class="headerlink" title="JavaScript 的基本语法"></a>JavaScript 的基本语法</h1><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。</p>
<p><strong>语句（statement）是为了完成某种任务而进行的操作，</strong>比如下面就是一行赋值语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句先用<code>var</code>命令，声明了变量<code>a</code>，然后将<code>1 + 3</code>的运算结果赋值给变量<code>a</code>。</p>
<p><code>1 + 3</code>叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。</p>
<p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span> ; <span class="keyword">var</span> b = <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;;;</span><br></pre></td></tr></table></figure>

<p>上面的代码就表示3个空语句。</p>
<p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">3</span>;</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码先声明变量<code>a</code>，然后在变量<code>a</code>与数值1之间建立引用关系，称为将数值1“赋值”给变量<code>a</code>。以后，引用变量名<code>a</code>就会得到数值1。最前面的<code>var</code>，是变量声明命令。它表示通知解释引擎，要创建一个变量<code>a</code>。</p>
<p><strong>注意，JavaScript 的变量名区分大小写，<code>A</code>和<code>a</code>是两个不同的变量。</strong></p>
<p>变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果只是声明变量而没有赋值，则该变量的值是<code>undefined</code>。<code>undefined</code>是一个特殊的值，表示“无定义”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>如果变量赋值的时候，忘了写<code>var</code>命令，这条语句也是有效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 基本等同</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>但是，不写<code>var</code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用<code>var</code>命令声明变量。</p>
<p>如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面代码直接使用变量<code>x</code>，系统就报错，告诉你变量<code>x</code>没有声明。</p>
<p>可以在同一条<code>var</code>命令中声明多个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br></pre></td></tr></table></figure>

<p><strong>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>a</code>起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量<code>a</code>已经存在，所以不需要使用<code>var</code>命令。</p>
<p>如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>x</code>声明了两次，第二次声明是无效的。</p>
<p>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><strong>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码首先使用<code>console.log</code>方法，在控制台（console）显示变量<code>a</code>的值。这时变量<code>a</code>还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>最后的结果是显示<code>undefined</code>，表示变量<code>a</code>已声明，但还未赋值。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><strong>标识符（identifier）指的是用来识别各种值的合法名称。</strong>最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以<code>a</code>和<code>A</code>是两个不同的标识符。</p>
<p><strong>标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。</strong></p>
<p>简单说，标识符命名规则如下。</p>
<ul>
<li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（<code>$</code>）和下划线（<code>_</code>）。</li>
<li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字<code>0-9</code>。</li>
</ul>
<p>下面这些都是合法的标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arg0</span><br><span class="line">_tmp</span><br><span class="line">$elem</span><br><span class="line">π</span><br></pre></td></tr></table></figure>

<p>下面这些则是不合法的标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>a  <span class="comment">// 第一个字符不能是数字</span></span><br><span class="line"><span class="number">23</span>  <span class="comment">// 同上</span></span><br><span class="line">***  <span class="comment">// 标识符不能包含星号</span></span><br><span class="line">a+b  <span class="comment">// 标识符不能包含加号</span></span><br><span class="line">-d  <span class="comment">// 标识符不能包含减号或连词线</span></span><br></pre></td></tr></table></figure>

<p><strong>中文是合法的标识符，可以用作变量名。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 临时变量 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p>
</blockquote>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用<code>//</code>起头；另一种是多行注释，放在<code>/*</code>和<code>*/</code>之间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这是</span></span><br><span class="line"><span class="comment"> 多行</span></span><br><span class="line"><span class="comment"> 注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以**<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释。**</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span>; &lt;!-- x = <span class="number">2</span>;</span><br><span class="line">--&gt; x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，只有<code>x = 1</code>会执行，其他的部分都被注释掉了。</p>
<p>需要注意的是，**<code>--&gt;</code>只有在行首，才会被当成单行注释，否则会当作正常的运算。**</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (n --&gt; <span class="number">0</span>) <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line">countdown(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>n --&gt; 0</code>实际上会当作<code>n-- &gt; 0</code>，因此输出2、1、0。</p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p><strong>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。</strong></p>
<p>对于<code>var</code>命令来说，JavaScript 的区块不构成单独的作用域（scope）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码在区块内部，使用<code>var</code>命令声明并赋值了变量<code>a</code>，然后在区块外部，变量<code>a</code>依然有效，区块对于<code>var</code>命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如<code>for</code>、<code>if</code>、<code>while</code>、<code>function</code>等。</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>JavaScript 提供<code>if</code>结构和<code>switch</code>结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。</p>
<h3 id="if-结构"><a href="#if-结构" class="headerlink" title="if 结构"></a>if 结构</h3><p><code>if</code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，<code>true</code>表示真，<code>false</code>表示<code>伪</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔值)</span><br><span class="line">  语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (布尔值) 语句;</span><br></pre></td></tr></table></figure>

<p>上面是<code>if</code>结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为<code>true</code>，就执行紧跟在后面的语句；如果结果为<code>false</code>，则跳过紧跟在后面的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>)</span><br><span class="line">  m = m + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，只有在<code>m</code>等于3时，才会将其值加上1。</p>
<p>这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在<code>if</code>的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) &#123;</span><br><span class="line">  m += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议总是在<code>if</code>语句中使用大括号，因为这样方便插入语句。</p>
<p>注意，<code>if</code>后面的表达式之中，不要混淆赋值表达式（<code>=</code>）、严格相等运算符（<code>===</code>）和相等运算符（<code>==</code>）。尤其是赋值表达式不具有比较作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x = y) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的原意是，当<code>x</code>等于<code>y</code>的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将<code>y</code>赋值给变量<code>x</code>，再判断变量<code>x</code>的值（等于2）的布尔值（结果为<code>true</code>）。</p>
<p>这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = <span class="number">2</span>) &#123; <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> = x) &#123; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>至于为什么优先采用“严格相等运算符”（<code>===</code>），而不是“相等运算符”（<code>==</code>），请参考《运算符》章节。</p>
<h3 id="if…else-结构"><a href="#if…else-结构" class="headerlink" title="if…else 结构"></a>if…else 结构</h3><p><code>if</code>代码块后面，还可以跟一个<code>else</code>代码块，表示不满足条件时，所要执行的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">// 满足条件时，执行的语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 不满足条件时，执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码判断变量<code>m</code>是否等于3，如果等于就执行<code>if</code>代码块，否则执行<code>else</code>代码块。</p>
<p>对同一个变量进行多次判断时，多个<code>if...else</code>语句可以连写在一起。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>else</code>代码块总是与离自己最近的那个<code>if</code>语句配对。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (n === <span class="number">2</span>) <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码不会有任何输出，<code>else</code>代码块不会得到执行，因为它跟着的是最近的那个<code>if</code>语句，相当于下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想让<code>else</code>代码块跟随最上面的那个<code>if</code>语句，就要改变大括号的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>

<h3 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h3><p>多个<code>if...else</code>连在一起使用的时候，可以转为使用更方便的<code>switch</code>结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;banana&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码根据变量<code>fruit</code>的值，选择执行相应的<code>case</code>。如果所有<code>case</code>都不符合，则执行最后的<code>default</code>部分。需要注意的是，每个<code>case</code>代码块内部的<code>break</code>语句不能少，否则会接下去执行下一个<code>case</code>代码块，而不是跳出<code>switch</code>结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x 等于1&#x27;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x 等于2&#x27;</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x 等于其他值&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x等于1</span></span><br><span class="line"><span class="comment">// x等于2</span></span><br><span class="line"><span class="comment">// x等于其他值</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>case</code>代码块之中没有<code>break</code>语句，导致不会跳出<code>switch</code>结构，而会一直执行下去。正确的写法是像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x 等于1&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x 等于2&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x 等于其他值&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code>语句部分和<code>case</code>语句部分，都可以使用表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span> + <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> + <span class="number">2</span>:</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    neverHappens();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>default</code>部分，是永远不会执行到的。</p>
<p>需要注意的是，<code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（<code>===</code>），而不是相等运算符（<code>==</code>），这意味着比较时不会发生类型转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x 发生类型转换&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x 没有发生类型转换&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x 没有发生类型转换</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于变量<code>x</code>没有发生类型转换，所以不会执行<code>case true</code>的情况。这表明，<code>switch</code>语句内部采用的是“严格相等运算符”，详细解释请参考《运算符》一节。</p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 ?:"></a>三元运算符 ?:</h3><p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）<code>?:</code>，也可以用于逻辑判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(条件) ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果“条件”为<code>true</code>，则返回“表达式1”的值，否则返回“表达式2”的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> even = (n % <span class="number">2</span> === <span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果<code>n</code>可以被2整除，则<code>even</code>等于<code>true</code>，否则等于<code>false</code>。它等同于下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> even;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">  even = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  even = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个三元运算符可以被视为<code>if...else...</code>的简写形式，因此可以用于多种场合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar;</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  myVar ?</span><br><span class="line">  <span class="string">&#x27;myVar has a value&#x27;</span> :</span><br><span class="line">  <span class="string">&#x27;myVar does not have a value&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// myVar does not have a value</span></span><br></pre></td></tr></table></figure>

<p>上面代码利用三元运算符，输出相应的提示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">&#x27;数字&#x27;</span> + n + <span class="string">&#x27;是&#x27;</span> + (n % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">&#x27;偶数&#x27;</span> : <span class="string">&#x27;奇数&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码利用三元运算符，在字符串之中插入不同的值。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式。</p>
<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><code>While</code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件)</span><br><span class="line">  语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">while</span> (条件) 语句;</span><br></pre></td></tr></table></figure>

<p><code>while</code>语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是<code>while</code>语句的一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;i 当前为：&#x27;</span> + i);</span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将循环100次，直到<code>i</code>等于100为止。</p>
<p>下面的例子是一个无限循环，因为循环条件总是为真。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><strong><code>for</code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。</strong>它的格式如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化表达式; 条件; 递增表达式)</span><br><span class="line">  语句</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (初始化表达式; 条件; 递增表达式) &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code>语句后面的括号里面，有三个表达式。</p>
<ul>
<li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。</li>
<li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li>
<li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，初始化表达式是<code>var i = 0</code>，即初始化一个变量<code>i</code>；测试表达式是<code>i &lt; x</code>，即只要<code>i</code>小于<code>x</code>，就会执行循环；递增表达式是<code>i++</code>，即每次循环结束后，<code>i</code>增大1。</p>
<p>所有<code>for</code>循环，都可以改写成<code>while</code>循环。上面的例子改为<code>while</code>循环，代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; x) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code>语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码省略了<code>for</code>语句表达式的三个部分，结果就导致了一个无限循环。</p>
<h3 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a>do…while 循环</h3><p><code>do...while</code>循环与<code>while</code>循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  语句</span><br><span class="line"><span class="keyword">while</span> (条件);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure>

<p>不管条件是否为真，<code>do...while</code>循环至少运行一次，这是这种结构最大的特点。另外，<code>while</code>语句后面的分号注意不要省略。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span>(i &lt; x);</span><br></pre></td></tr></table></figure>

<h3 id="break-语句和-continue-语句"><a href="#break-语句和-continue-语句" class="headerlink" title="break 语句和 continue 语句"></a>break 语句和 continue 语句</h3><p><code>break</code>语句和<code>continue</code>语句都具有跳转作用，可以让代码不按既有的顺序执行。</p>
<p><code>break</code>语句用于跳出代码块或循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params">i &lt; <span class="number">100</span></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;i 当前为：&#x27;</span> + i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码只会执行10次循环，一旦<code>i</code>等于10，就会跳出循环。</p>
<p><code>for</code>循环也可以使用<code>break</code>语句跳出循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码执行到<code>i</code>等于3，就会跳出循环。</p>
<p><code>continue</code>语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;i 当前为：&#x27;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码只有在<code>i</code>为奇数时，才会输出<code>i</code>的值。如果<code>i</code>为偶数，则直接进入下一轮循环。</p>
<p>如果存在多重循环，不带参数的<code>break</code>语句和<code>continue</code>语句都只针对最内层循环。</p>
<h3 id="标签（label）"><a href="#标签（label）" class="headerlink" title="标签（label）"></a>标签（label）</h3><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">label:</span><br><span class="line">  语句</span><br></pre></td></tr></table></figure>

<p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p>
<p>标签通常与<code>break</code>语句和<code>continue</code>语句配合使用，跳出特定的循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br></pre></td></tr></table></figure>

<p>上面代码为一个双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，<code>top</code>不用加引号），满足条件时，直接跳出双层循环。如果<code>break</code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p>
<p>标签也可以用于跳出代码块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;本行不会输出&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码执行到<code>break foo</code>，就会跳出区块。</p>
<p><code>continue</code>语句也可以与标签配合使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">continue</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=1</span></span><br><span class="line"><span class="comment">// i=2, j=2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>continue</code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果<code>continue</code>语句后面不使用标签，则只能进入下一轮的内层循环。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/10/javascript-overview.html">A quick overview of JavaScript</a></li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 语言的历史</title>
    <url>/2020/10/26/kuku_class_content/2-history_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="JavaScript-语言的历史"><a href="#JavaScript-语言的历史" class="headerlink" title="JavaScript 语言的历史"></a>JavaScript 语言的历史</h1><h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p><strong>JavaScript 因为互联网而生，紧跟着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。</strong></p>
<p>1990年底，欧洲核能研究组织（CERN）科学家 Tim Berners-Lee，在全世界最大的电脑网络——互联网的基础上，发明了万维网（World Wide Web），从此可以在网上浏览网页文件。最早的网页只能在操作系统的终端里浏览，也就是说只能使用命令行操作，网页都是在字符窗口中显示，这当然非常不方便。</p>
<p><strong>1992年底</strong>，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做 Mosaic。这是<strong>人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览。</strong></p>
<p>1994年10月，NCSA 的一个主要程序员 Marc Andreessen 联合风险投资家 Jim Clark，成立了 Mosaic 通信公司（Mosaic Communications），不久后改名为 Netscape。这家公司的方向，就是在 Mosaic 的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。</p>
<p>1994年12月，Navigator 发布了1.0版，市场份额一举超过90%。</p>
<p>Netscape 公司很快发现，Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。</p>
<p>管理层对这种浏览器脚本语言的设想是：功能不需要太强，语法较为简单，容易学习和部署。那一年，正逢 Sun 公司的 Java 语言问世，市场推广活动非常成功。Netscape 公司决定与 Sun 公司合作，浏览器支持嵌入 Java 小程序（后来称为 Java applet）。但是，浏览器脚本语言是否就选用 Java，则存在争论。后来，还是决定不使用 Java，因为网页小程序不需要 Java 这么“重”的语法。但是，同时也决定脚本语言的语法要接近 Java，并且可以支持 Java 程序。这些设想直接排除了使用现存语言，比如 Perl、Python 和 TCL。</p>
<p>1995年，Netscape 公司雇佣了程序员 Brendan Eich 开发这种网页脚本语言。Brendan Eich 有很强的函数式编程背景，希望以 Scheme 语言（函数式语言鼻祖 LISP 语言的一种方言）为蓝本，实现这种新语言。</p>
<p>1995年5月，Brendan Eich 只用了10天，就设计完成了这种语言的第一版。它是一个大杂烩，语法有多个来源。</p>
<ul>
<li>基本语法：借鉴 C 语言和 Java 语言。</li>
<li>数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。</li>
<li>函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。</li>
<li>原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。</li>
<li>正则表达式：借鉴 Perl 语言。</li>
<li>字符串和数组处理：借鉴 Python 语言。</li>
</ul>
<p><strong>为了保持简单，这种脚本语言缺少一些关键的功能，比如块级作用域、模块、子类型（subtyping）等等，</strong>但是可以利用现有功能找出解决办法。这种功能的不足，<strong>直接导致了后来 JavaScript 的一个显著特点</strong>：对于其他语言，你需要学习语言的各种功能，而对于 JavaScript，你常常需要学习各种解决问题的模式。而且由于来源多样，<strong>从一开始就注定，JavaScript 的编程风格是函数式编程和面向对象编程的一种混合体。</strong></p>
<p>Netscape 公司的这种浏览器脚本语言，最初名字叫做 Mocha，1995年9月改为 LiveScript。12月，Netscape 公司与 Sun 公司（Java 语言的发明者和所有者）达成协议，后者允许将这种语言叫做 JavaScript。这样一来，Netscape 公司可以借助 Java 语言的声势，而 Sun 公司则将自己的影响力扩展到了浏览器。</p>
<p>之所以起这个名字，并不是因为 JavaScript 本身与 Java 语言有多么深的关系（事实上，两者关系并不深，详见下节），而是因为 Netscape 公司已经决定，使用 Java 语言开发网络应用程序，JavaScript 可以像胶水一样，将各个部分连接起来。当然，后来的历史是 Java 语言的浏览器插件失败了，JavaScript 反而发扬光大。</p>
<p><strong>1995年12月4日，Netscape 公司与 Sun 公司联合发布了 JavaScript 语言，对外宣传 JavaScript 是 Java 的补充，属于轻量级的 Java，专门用来操作网页。</strong></p>
<p><strong>1996年3月，Navigator 2.0 浏览器正式内置了 JavaScript 脚本语言。</strong></p>
<h2 id="JavaScript-与-Java-的关系"><a href="#JavaScript-与-Java-的关系" class="headerlink" title="JavaScript 与 Java 的关系"></a>JavaScript 与 Java 的关系</h2><p>这里专门说一下 JavaScript 和 Java 的关系。它们是两种不一样的语言，但是彼此存在联系。</p>
<p><strong>JavaScript 的基本语法和对象体系，是模仿 Java 而设计的。</strong>但是，JavaScript 没有采用 Java 的静态类型。正是因为 JavaScript 与 Java 有很大的相似性，所以这门语言才从一开始的 LiveScript 改名为 JavaScript。基本上，JavaScript 这个名字的原意是“很像Java的脚本语言”。</p>
<p><strong>JavaScript 语言的函数是一种独立的数据类型，以及采用基于原型对象（prototype）的继承链。这是它与 Java 语法最大的两点区别。</strong>JavaScript 语法要比 Java 自由得多。</p>
<p>另外，Java 语言需要编译，而 JavaScript 语言则是运行时由解释器直接执行。</p>
<p>总之，JavaScript 的原始设计目标是一种小型的、简单的动态语言，与 Java 有足够的相似性，使得使用者（尤其是 Java 程序员）可以快速上手。</p>
<h2 id="JavaScript-与-ECMAScript-的关系"><a href="#JavaScript-与-ECMAScript-的关系" class="headerlink" title="JavaScript 与 ECMAScript 的关系"></a>JavaScript 与 ECMAScript 的关系</h2><p>1996年8月，微软模仿 JavaScript 开发了一种相近的语言，取名为JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。</p>
<p>1996年11月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的39号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共25个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。</p>
<p>1997年7月，ECMA 组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，<strong>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。</strong>在日常场合，这两个词是可以互换的。</p>
<p>ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C组织（World Wide Web Consortium）制定的。</p>
<p>ECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。</p>
<h2 id="JavaScript-的版本"><a href="#JavaScript-的版本" class="headerlink" title="JavaScript 的版本"></a>JavaScript 的版本</h2><p>1997年7月，ECMAScript 1.0发布。</p>
<p>1998年6月，ECMAScript 2.0版发布。</p>
<p>1999年12月，ECMAScript 3.0版发布，成为 JavaScript 的通行标准，得到了广泛支持。</p>
<p>2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。</p>
<p>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p>
<p><strong>2009年12月，ECMAScript 5.0版 正式发布。</strong>Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 的总体考虑是，ECMAScript 5 与 ECMAScript 3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是ECMAScript 6。第六版发布以后，将指 ECMAScript 7。TC39 预计，ECMAScript 5 会在2013年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。</p>
<p>2011年6月，ECMAScript 5.1版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。</p>
<p>2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。</p>
<p>2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。</p>
<p><strong>2015年6月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。</strong>这是因为 TC39 委员会计划，以后每年发布一个 ECMAScript 的版本，下一个版本在2016年发布，称为“ECMAScript 2016”，2017年发布“ECMAScript 2017”，以此类推。</p>
<h2 id="周边大事记"><a href="#周边大事记" class="headerlink" title="周边大事记"></a>周边大事记</h2><p>JavaScript 伴随着互联网的发展一起发展。互联网周边技术的快速发展，刺激和推动了 JavaScript 语言的发展。下面，回顾一下 JavaScript 的周边应用发展。</p>
<p>1996年，样式表标准 CSS 第一版发布。</p>
<p>1997年，DHTML（Dynamic HTML，动态 HTML）发布，允许动态改变网页内容。这标志着 DOM 模式（Document Object Model，文档对象模型）正式应用。</p>
<p>1998年，Netscape 公司开源了浏览器，这导致了 Mozilla 项目的诞生。几个月后，美国在线（AOL）宣布并购 Netscape。</p>
<p>1999年，IE 5部署了 XMLHttpRequest 接口，允许 JavaScript 发出 HTTP 请求，为后来大行其道的 Ajax 应用创造了条件。</p>
<p>2000年，KDE 项目重写了浏览器引擎 KHTML，为后来的 WebKit 和 Blink 引擎打下基础。这一年的10月23日，KDE 2.0发布，第一次将 KHTML 浏览器包括其中。</p>
<p>2001年，微软公司时隔5年之后，发布了 IE 浏览器的下一个版本 Internet Explorer 6。这是当时最先进的浏览器，它后来统治了浏览器市场多年。</p>
<p>2001年，Douglas Crockford 提出了 JSON 格式，用于取代 XML 格式，进行服务器和网页之间的数据交换。JavaScript 可以原生支持这种格式，不需要额外部署代码。</p>
<p><strong>2002年，Mozilla 项目发布了它的浏览器的第一版，后来起名为 Firefox。</strong></p>
<p><strong>2003年，苹果公司发布了 Safari 浏览器的第一版。</strong></p>
<p>2004年，Google 公司发布了 Gmail，促成了互联网应用程序（Web Application）这个概念的诞生。由于 Gmail 是在4月1日发布的，很多人起初以为这只是一个玩笑。</p>
<p>2004年，Dojo 框架诞生，为不同浏览器提供了同一接口，并为主要功能提供了便利的调用方法。这标志着 JavaScript 编程框架的时代开始来临。</p>
<p>2004年，WHATWG 组织成立，致力于加速 HTML 语言的标准化进程。</p>
<p>2005年，苹果公司在 KHTML 引擎基础上，建立了 WebKit 引擎。</p>
<p>2<strong>005年，Ajax 方法（Asynchronous JavaScript and XML）正式诞生</strong>，Jesse James Garrett 发明了这个词汇。它开始流行的标志是，2月份发布的 Google Maps 项目大量采用该方法。它几乎成了新一代网站的标准做法，促成了 Web 2.0时代的来临。</p>
<p>2005年，Apache 基金会发布了 CouchDB 数据库。这是一个基于 JSON 格式的数据库，可以用 JavaScript 函数定义视图和索引。它在本质上有别于传统的关系型数据库，标识着 NoSQL 类型的数据库诞生。</p>
<p><strong>2006年，jQuery 函数库诞生，</strong>作者为John Resig。jQuery 为操作网页 DOM 结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让 JavaScript 语言的应用难度大大降低，推动了这种语言的流行。</p>
<p>2006年，微软公司发布 IE 7，标志重新开始启动浏览器的开发。</p>
<p>2006年，Google推出 Google Web Toolkit 项目（缩写为 GWT），提供 Java 编译成 JavaScript 的功能，开创了将其他语言转为 JavaScript 的先河。</p>
<p>2007年，Webkit 引擎在 iPhone 手机中得到部署。它最初基于 KDE 项目，2003年苹果公司首先采用，2005年开源。这标志着 JavaScript 语言开始能在手机中使用了，意味着有可能写出在桌面电脑和手机中都能使用的程序。</p>
<p>2007年，Douglas Crockford 发表了名为《JavaScript: The good parts》的演讲，次年由 O’Reilly 出版社出版。这标志着软件行业开始严肃对待 JavaScript 语言，对它的语法开始重新认识，</p>
<p><strong>2008年，V8 编译器诞生</strong>。这是 Google 公司为 Chrome 浏览器而开发的，它的特点是让 JavaScript 的运行变得非常快。它提高了 JavaScript 的性能，推动了语法的改进和标准化，改变外界对 JavaScript 的不佳印象。同时，V8 是开源的，任何人想要一种快速的嵌入式脚本语言，都可以采用 V8，这拓展了 JavaScript 的应用领域。</p>
<p><strong>2009年，Node.js 项目诞生</strong>，创始人为 Ryan Dahl，它标志着 JavaScript 可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js 可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。</p>
<p>2009年，Jeremy Ashkenas 发布了 CoffeeScript 的最初版本。CoffeeScript 可以被转换为 JavaScript 运行，但是语法要比 JavaScript 简洁。这开启了其他语言转为 JavaScript 的风潮。</p>
<p>2009年，PhoneGap 项目诞生，它将 HTML5 和 JavaScript 引入移动设备的应用程序开发，主要针对 iOS 和 Android 平台，使得 JavaScript 可以用于跨平台的应用程序开发。</p>
<p>2009，Google 发布 Chrome OS，号称是以浏览器为基础发展成的操作系统，允许直接使用 JavaScript 编写应用程序。类似的项目还有 Mozilla 的 Firefox OS。</p>
<p><strong>2010年，三个重要的项目诞生，分别是 NPM、BackboneJS 和 RequireJS，标志着 JavaScript 进入模块化开发的时代。</strong></p>
<p>2011年，微软公司发布 Windows 8操作系统，将 JavaScript 作为应用程序的开发语言之一，直接提供系统支持。</p>
<p><strong>2011年，Google 发布了 Dart 语言，</strong>目的是为了结束 JavaScript 语言在浏览器中的垄断，提供更合理、更强大的语法和功能。Chromium浏览器有内置的 Dart 虚拟机，可以运行 Dart 程序，但 Dart 程序也可以被编译成 JavaScript 程序运行。</p>
<p>2011年，微软工程师<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">Scott Hanselman</a>提出，JavaScript 将是互联网的汇编语言。因为它无所不在，而且正在变得越来越快。其他语言的程序可以被转成 JavaScript 语言，然后在浏览器中运行。</p>
<p><strong>2012年，单页面应用程序框架（single-page app framework）开始崛起，AngularJS 项目和 Ember 项目都发布了1.0版本。</strong></p>
<p>2<strong>012年，微软发布 TypeScript 语言。该语言被设计成 JavaScript 的超集，</strong>这意味着所有 JavaScript 程序，都可以不经修改地在 TypeScript 中运行。同时，TypeScript 添加了很多新的语法特性，主要目的是为了开发大型程序，然后还可以被编译成 JavaScript 运行。</p>
<p>2012年，Mozilla 基金会提出 <a href="http://asmjs.org/">asm.js</a> 规格。asm.js 是 JavaScript 的一个子集，所有符合 asm.js 的程序都可以在浏览器中运行，它的特殊之处在于语法有严格限定，可以被快速编译成性能良好的机器码。这样做的目的，是为了给其他语言提供一个编译规范，使其可以被编译成高效的 JavaScript 代码。同时，Mozilla 基金会还发起了 <a href="https://github.com/kripken/emscripten/wiki">Emscripten</a> 项目，目标就是提供一个跨语言的编译器，能够将 LLVM 的位代码（bitcode）转为 JavaScript 代码，在浏览器中运行。因为大部分 LLVM 位代码都是从 C / C++ 语言生成的，这意味着 C / C++ 将可以在浏览器中运行。此外，Mozilla 旗下还有 <a href="http://mbebenita.github.io/LLJS/">LLJS</a> （将 JavaScript 转为 C 代码）项目和 <a href="https://github.com/RiverTrail/RiverTrail/wiki">River Trail</a> （一个用于多核心处理器的 ECMAScript 扩展）项目。目前，可以被编译成 JavaScript 的<a href="https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS">语言列表</a>，共有将近40种语言。</p>
<p>2013年，Mozilla 基金会发布手机操作系统 Firefox OS，该操作系统的整个用户界面都使用 JavaScript。</p>
<p><strong>2013年，ECMA 正式推出 JSON 的<a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm">国际标准</a>，这意味着 JSON 格式已经变得与 XML 格式一样重要和正式了。</strong></p>
<p><strong>2013年5月，Facebook 发布 UI 框架库 React</strong>，引入了新的 JSX 语法，使得 UI 层可以用组件开发，同时引入了网页应用是状态机的概念。</p>
<p>2014年，微软推出 JavaScript 的 Windows 库 WinJS，标志微软公司全面支持 JavaScript 与 Windows 操作系统的融合。</p>
<p>2014年11月，由于对 Joyent 公司垄断 Node 项目、以及该项目进展缓慢的不满，一部分核心开发者离开了 Node.js，创造了 io.js 项目，这是一个更开放、更新更频繁的 Node.js 版本，很短时间内就发布到了2.0版。三个月后，Joyent 公司宣布放弃对 Node 项目的控制，将其转交给新成立的开放性质的 Node 基金会。随后，io.js 项目宣布回归 Node，两个版本将合并。</p>
<p><strong>2015年3月，Facebook 公司发布了 React Native 项目，将 React 框架移植到了手机端，可以用来开发手机 App。</strong>它会将 JavaScript 代码转为 iOS 平台的 Objective-C 代码，或者 Android 平台的 Java 代码，从而为 JavaScript 语言开发高性能的原生 App 打开了一条道路。</p>
<p>2<strong>015年4月，Angular 框架宣布，2.0 版将基于微软公司的TypeScript语言开发，这等于为 JavaScript 语言引入了强类型。</strong></p>
<p>2015年5月，Node 模块管理器 NPM 超越 CPAN，标志着 JavaScript 成为世界上软件模块最多的语言。</p>
<p>2015年5月，Google 公司的 Polymer 框架发布1.0版。该项目的目标是生产环境可以使用 WebComponent 组件，如果能够达到目标，Web 开发将进入一个全新的以组件为开发基础的阶段。</p>
<p>2015年6月，ECMA 标准化组织正式批准了 ECMAScript 6 语言标准，定名为《ECMAScript 2015 标准》。JavaScript 语言正式进入了下一个阶段，成为一种企业级的、开发大规模应用的语言。这个标准从提出到批准，历时10年，而 JavaScript 语言从诞生至今也已经20年了。</p>
<p>2015年6月，Mozilla 在 asm.js 的基础上发布 WebAssembly 项目。这是一种 JavaScript 引擎的中间码格式，全部都是二进制，类似于 Java 的字节码，有利于移动设备加载 JavaScript 脚本，执行速度提高了 20+ 倍。这意味着将来的软件，会发布 JavaScript 二进制包。</p>
<p>2016年6月，《ECMAScript 2016 标准》发布。与前一年发布的版本相比，它只增加了两个较小的特性。</p>
<p>2017年6月，《ECMAScript 2017 标准》发布，正式引入了 async 函数，使得异步操作的写法出现了根本的变化。</p>
<p><strong>2017年11月，所有主流浏览器全部支持 WebAssembly，这意味着任何语言都可以编译成 JavaScript，在浏览器运行。</strong></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Axel Rauschmayer, <a href="http://oreilly.com/javascript/radarreports/past-present-future-javascript.csp">The Past, Present, and Future of JavaScript</a></li>
<li>John Dalziel, <a href="http://creativejs.com/2013/06/the-race-for-speed-part-4-the-future-for-javascript/">The race for speed part 4: The future for JavaScript</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/06/basic-javascript.html">Basic JavaScript for the impatient programmer</a></li>
<li>resin.io, <a href="http://resin.io/happy-18th-birthday-javascript/">Happy 18th Birthday JavaScript! A look at an unlikely past and bright future</a></li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 ECMAScript 5.1 版本</title>
    <url>/2020/10/26/kuku_class_content/1-introduction_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><p>基于 ECMAScript 5.1 版本</p>
<h2 id="什么是-JavaScript-语言？"><a href="#什么是-JavaScript-语言？" class="headerlink" title="什么是 JavaScript 语言？"></a>什么是 JavaScript 语言？</h2><p><strong>JavaScript 是一种轻量级的脚本语言。</strong>所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写<strong>控制</strong>其他大型应用程序（比如浏览器）的“脚本”。</p>
<p><strong>JavaScript 也是一种嵌入式（embedded）语言。</strong>它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。<strong>JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API</strong>。</p>
<p>目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</p>
<p><strong>从语法角度看，JavaScript 语言是一种“对象模型”语言。</strong>各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，<strong>JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如函数式编程）。这导致几乎任何一个问题，JavaScript 都有多种解决方法。</strong></p>
<p>JavaScript 的核心语法部分相当精简，只包括两个部分：<strong>基本的语法构造</strong>（比如操作符、控制结构、语句）和<strong>标准库</strong>（就是一系列具有各种功能的对象比如<code>Array</code>、<code>Date</code>、<code>Math</code>等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。</p>
<ul>
<li>浏览器控制类：操作浏览器</li>
<li>DOM 类：操作网页的各种元素</li>
<li>Web 类：实现互联网的各种功能</li>
</ul>
<p>如果宿主环境是服务器，比如Node，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API等等。本次主要学习 JavaScript 核心语法和浏览器网页开发的基本知识，不涉及 Node。</p>
<h2 id="为什么学习-JavaScript？"><a href="#为什么学习-JavaScript？" class="headerlink" title="为什么学习 JavaScript？"></a>为什么学习 JavaScript？</h2><p>JavaScript 语言有一些显著特点，使得它非常值得学习。它既适合作为学习编程的入门语言，也适合当作日常开发的工作语言。它是目前最有希望、前途最光明的计算机语言之一。</p>
<h3 id="操控浏览器的能力"><a href="#操控浏览器的能力" class="headerlink" title="操控浏览器的能力"></a>操控浏览器的能力</h3><p>JavaScript 的发明目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力。它是目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。它可以让网页呈现各种特殊效果，为用户提供良好的互动体验。</p>
<p>对于一个互联网开发者来说，如果你想提供漂亮的网页、令用户满意的上网体验、各种基于浏览器的便捷功能、前后端之间紧密高效的联系，JavaScript 是必不可少的工具。目前，全世界几乎所有网页都使用 JavaScript。</p>
<h3 id="广泛的使用领域"><a href="#广泛的使用领域" class="headerlink" title="广泛的使用领域"></a>广泛的使用领域</h3><p>近年来，JavaScript 的使用范围，慢慢超越了浏览器，正在向通用的系统语言发展。</p>
<p><strong>（1）浏览器的平台化</strong></p>
<p>随着 HTML5 的出现，浏览器本身的功能越来越强，不再仅仅能浏览网页，而是越来越像一个平台，JavaScript 因此得以调用许多系统功能，比如操作本地文件、操作图片、调用摄像头和麦克风等等。这使得 JavaScript 可以完成许多以前无法想象的事情。</p>
<p><strong>（2）Node</strong></p>
<p><strong>Node 项目使得 JavaScript 可以用于开发服务器端的大型项目，</strong>网站的前后端都用 JavaScript 开发已经成为了现实。</p>
<p><strong>（3）数据库操作</strong></p>
<p>J<strong>avaScript 甚至也可以用来操作数据库。</strong>NoSQL 数据库这个概念，本身就是在 JSON（JavaScript Object Notation）格式的基础上诞生的，大部分 NoSQL 数据库允许 JavaScript 直接操作。基于 SQL 语言的开源数据库 PostgreSQL 支持 JavaScript 作为操作语言，可以部分取代 SQL 查询语言。</p>
<p><strong>（4）移动平台开发</strong></p>
<p><strong>JavaScript 也正在成为手机应用的开发语言。</strong>一般来说，安卓平台使用 Java 语言开发，iOS 平台使用 Objective-C 或 Swift 语言开发。许多人正在努力，让 JavaScript 成为各个平台的通用开发语言。</p>
<p>PhoneGap 项目就是将 JavaScript 和 HTML5 打包在一个容器之中，使得它能同时在 iOS 和安卓上运行。<strong>Facebook 公司的 React Native 项目则是将 JavaScript 写的组件，编译成原生组件，从而使它们具备优秀的性能。</strong></p>
<p>Mozilla 基金会的手机操作系统 Firefox OS，更是直接将 JavaScript 作为操作系统的平台语言，但是很可惜这个项目没有成功。</p>
<p><strong>（5）内嵌脚本语言</strong></p>
<p>越来越多的应用程序，将 JavaScript 作为内嵌的脚本语言，比如 Adobe 公司的著名 PDF 阅读器 Acrobat、Linux 桌面环境 GNOME 3。</p>
<p><strong>（6）跨平台的桌面应用程序</strong></p>
<p>Chromium OS、Windows 8 等操作系统直接支持 JavaScript 编写应用程序。Mozilla 的 Open Web Apps 项目、Google 的 <a href="http://developer.chrome.com/apps/about_apps">Chrome App 项目</a>、GitHub 的 <a href="http://electron.atom.io/">Electron 项目</a>、以及 <a href="http://tidesdk.multipart.net/docs/user-dev/generated/">TideSDK 项目</a>，都<strong>可以用来编写运行于 Windows、Mac OS 和 Android 等多个桌面平台的程序，不依赖浏览器。</strong></p>
<p><strong>（7）小结</strong></p>
<p>可以预期，JavaScript 最终将能让你只用一种语言，就开发出适应不同平台（包括桌面端、服务器端、手机端）的程序。早在2013年9月的<a href="http://adambard.com/blog/top-github-languages-for-2013-so-far/">统计</a>之中，JavaScript 就是当年 GitHub 上使用量排名第一的语言。</p>
<p>著名程序员 Jeff Atwood 甚至提出了一条 <a href="http://www.codinghorror.com/blog/2007/07/the-principle-of-least-power.html">“Atwood 定律”</a>：</p>
<blockquote>
<p>“所有可以用 JavaScript 编写的程序，最终都会出现 JavaScript 的版本。”(Any application that can be written in JavaScript will eventually be written in JavaScript.)</p>
</blockquote>
<h3 id="易学性"><a href="#易学性" class="headerlink" title="易学性"></a>易学性</h3><p>相比学习其他语言，学习 JavaScript 有一些有利条件。</p>
<p><strong>（1）学习环境无处不在</strong></p>
<p>只要有浏览器，就能运行 JavaScript 程序；只要有文本编辑器，就能编写 JavaScript 程序。这意味着，几乎所有电脑都原生提供 JavaScript 学习环境，不用另行安装复杂的 IDE（集成开发环境）和编译器。</p>
<p><strong>（2）简单性</strong></p>
<p>相比其他脚本语言（比如 Python 或 Ruby），JavaScript 的语法相对简单一些，本身的语法特性并不是特别多。而且，那些语法中的复杂部分，也不是必需要学会。你完全可以只用简单命令，完成大部分的操作。</p>
<p><strong>（3）与主流语言的相似性</strong></p>
<p>JavaScript 的语法很类似 C/C++ 和 Java，但是JavaScript 的入门会非常容易。</p>
<p>必须说明的是，虽然核心语法不难，但是 <strong>JavaScript 的复杂性</strong>体现在另外两个方面。</p>
<p>首先，<strong>它涉及大量的外部 API</strong>。JavaScript 要发挥作用，必须与其他组件配合，这些外部组件五花八门，数量极其庞大，几乎涉及网络应用的各个方面，掌握它们绝非易事。</p>
<p>其次，JavaScript 语言有一些设计缺陷。某些地方相当不合理，另一些地方则会出现怪异的运行结果。学习 JavaScript，很大一部分时间是用来搞清楚哪些地方有陷阱。另外一些程序员则感到，为了更合理地编写 JavaScript 程序，就不能用 JavaScript 来写，而必须发明新的语言，比如 CoffeeScript、TypeScript、Dart 这些新语言的发明目的，多多少少都有这个因素。</p>
<p>尽管如此，目前看来，JavaScript 的地位还是无法动摇。加之，语言标准的快速进化，使得 JavaScript 功能日益增强，而语法缺陷和怪异之处得到了弥补。所以，JavaScript 还是值得学习，况且它的入门真的不难。</p>
<h3 id="强大的性能"><a href="#强大的性能" class="headerlink" title="强大的性能"></a>强大的性能</h3><p>JavaScript 的性能优势体现在以下方面。</p>
<p><strong>（1）灵活的语法，表达力强。</strong></p>
<p>JavaScript 既支持类似 C 语言清晰的过程式编程，也支持灵活的函数式编程，可以用来写并发处理（concurrent）。这些语法特性已经被证明非常强大，可以用于许多场合，尤其适用异步编程。</p>
<p>JavaScript 的所有值都是对象，这为程序员提供了灵活性和便利性。因为你可以很方便地、按照需要随时创造数据结构，不用进行麻烦的预定义。</p>
<p>JavaScript 的标准还在快速进化中，并不断合理化，添加更适用的语法特性。</p>
<p><strong>（2）支持编译运行。</strong></p>
<p>JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。</p>
<p>此外，还有一种 WebAssembly 格式，它是 JavaScript 引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是 C 和 C++）通过编译成 WebAssembly，就可以在浏览器里面运行。</p>
<p><strong>（3）事件驱动和非阻塞式设计。</strong></p>
<p>JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。</p>
<h3 id="开放性"><a href="#开放性" class="headerlink" title="开放性"></a>开放性</h3><p>JavaScript 是一种开放的语言，这门语言不属于任何公司或个人，不存在版权和专利的问题。</p>
<p>不同公司的 JavaScript 运行环境，兼容性很好，程序不做调整或只做很小的调整，就能在所有浏览器上运行。</p>
<h3 id="社区支持和就业机会"><a href="#社区支持和就业机会" class="headerlink" title="社区支持和就业机会"></a>社区支持和就业机会</h3><p>全世界程序员都在使用 JavaScript，它有着极大的社区、广泛的文献和图书、丰富的代码资源。绝大部分你需要用到的功能，都有多个开源函数库可供选用。</p>
<p>作为项目负责人，你不难招聘到数量众多的 JavaScript 程序员；作为开发者，你也不难找到一份 JavaScript 的工作。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p> Chrome 浏览器，它的“开发者工具”（Developer Tools）里面的“控制台”（console），就是运行 JavaScript 代码的理想环境。</p>
<p>进入 Chrome 浏览器的“控制台”，有两种方法。</p>
<ul>
<li><p>直接进入：按下<code>Option + Command + J</code>（Mac）或者<code>Ctrl + Shift + J</code>（Windows / Linux）</p>
</li>
<li><p>开发者工具进入：开发者工具的快捷键是 F12，或者<code>Option + Command + I</code>（Mac）以及<code>Ctrl + Shift + I</code>（Windows / Linux），然后选择 Console 面板</p>
</li>
<li><p>按<code>Shift + Enter</code>键，就是代码换行，不会触发执行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-content</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-content</tag>
      </tags>
  </entry>
  <entry>
    <title>学习/复习markdown语法</title>
    <url>/2020/10/22/kuku_class_homework_dayao/class1_homework/%E7%86%9F%E6%82%89markdown%E8%AF%AD%E6%B3%95%E5%92%8Clinux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="作业1-学习-复习markdown语法"><a href="#作业1-学习-复习markdown语法" class="headerlink" title="作业1: 学习/复习markdown语法"></a>作业1: 学习/复习markdown语法</h3><h4 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h4><p>HTML 的全称是hypertext markup language ，注意里面的markup ，刚好和markdown 相反，所以Markdown的意思应该是反标记。 Markdown都不是用来替代 HTML 的，更不是用于前端开发、写完整页面的。Markdown 的设计目的是方便写作的时候，标记格式、同时使标记格式后的纯文本，比起 HTML 源码，更有可读性。</p>
<table>
<thead>
<tr>
<th align="center">markdown语法</th>
<th align="center">语法糖</th>
<th align="center">案例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标题</td>
<td align="center">一个#是一级标题，二个#是二级标题，以此类推。<br>注：标准语法一般在#后跟个空格再写文字</td>
<td align="center"># tyw</td>
</tr>
<tr>
<td align="center">字体-加粗</td>
<td align="center">左右分别用两个*号包起来</td>
<td align="center"><strong>这是加粗的文字</strong></td>
</tr>
<tr>
<td align="center">字体-斜体</td>
<td align="center">左右分别用一个*号包起来</td>
<td align="center"><em>这是倾斜的文字</em></td>
</tr>
<tr>
<td align="center">字体-斜体加粗</td>
<td align="center">左右分别用三个*号包起来</td>
<td align="center"><strong><em>这是斜体加粗的文字</em></strong></td>
</tr>
<tr>
<td align="center">字体-删除线</td>
<td align="center">左右分别用两个~~号包起来</td>
<td align="center"><del>这是加删除线的文字</del></td>
</tr>
<tr>
<td align="center">引用</td>
<td align="center">在引用的文字前加&gt;即可。<br>引用也可以嵌套，如加两个&gt;&gt;三个<br>&gt;&gt;&gt; n个…</td>
<td align="center">&gt; 这是引用的内容</td>
</tr>
<tr>
<td align="center">图片</td>
<td align="center">![图片alt](图片地址 ‘’图片title’’)<br/><br/>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br/>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">超链接</td>
<td align="center"><a href="%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" title="超链接title">超链接名</a><br/>title可加可不加</td>
<td align="center"><a href="http://jianshu.com/" title="baidu">简书</a><br/></td>
</tr>
<tr>
<td align="center">列表-无序列表</td>
<td align="center">无序列表用 - + * 任何一种都可以</td>
<td align="center">- 列表内容<br/>+ 列表内容<br/>* 列表内容<br/><br/>注意：- + * 跟内容之间都要有一个空格</td>
</tr>
<tr>
<td align="center">列表-有序列表</td>
<td align="center">数字加点</td>
<td align="center">1. 列表内容 2. 列表内容 3. 列表内容  注意：序号跟内容之间要有空格</td>
</tr>
<tr>
<td align="center">表格</td>
<td align="center">|,原声语法两边都要用｜包起来</td>
<td align="center">|dayao1|dayao2|</td>
</tr>
<tr>
<td align="center">代码-单行代码</td>
<td align="center">单行代码：代码之间分别用一个反引号包起来</td>
<td align="center"><code>代码内容</code></td>
</tr>
<tr>
<td align="center">代码-代码块</td>
<td align="center">代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</td>
<td align="center"><code>we</code></td>
</tr>
<tr>
<td align="center">流程图</td>
<td align="center">flow</td>
<td align="center"><code>flow&lt;br/&gt;st=&gt;start: 开始&lt;br/&gt;op=&gt;operation: My Operation&lt;br/&gt;cond=&gt;condition: Yes or No?&lt;br/&gt;e=&gt;end&lt;br/&gt;st-&gt;op-&gt;cond&lt;br/&gt;cond(yes)-&gt;e&lt;br/&gt;cond(no)-&gt;op&lt;br/&gt;&amp;</code></td>
</tr>
</tbody></table>
<h3 id="作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get"><a href="#作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get" class="headerlink" title="作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get"></a>作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Tab</td>
<td align="center">具有『命令补全』不『档案补齐』的功能</td>
<td align="center">常用热键</td>
</tr>
<tr>
<td align="center">Ctrl+c</td>
<td align="center">让当前的程序『停掉』</td>
<td align="center">常用热键</td>
</tr>
<tr>
<td align="center">Ctrl+d</td>
<td align="center">通常代表着：『键盘输入结束(End Of File, EOF 戒 End OfInput)』的意思；另外，他也可以用来取代exit</td>
<td align="center">常用热键</td>
</tr>
<tr>
<td align="center">cd</td>
<td align="center">切换目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">pwd</td>
<td align="center">显示当前所在目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">mkdir</td>
<td align="center">建立新目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">rmdir</td>
<td align="center">删除空目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ls</td>
<td align="center">档案与目录的显示</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">cp</td>
<td align="center">复制档案或目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">rm</td>
<td align="center">移除档案或目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">mv</td>
<td align="center">移动档案与目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">basename、dirname</td>
<td align="center">取得路径的文件名与目录名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">cat</td>
<td align="center">由第一行开始显示档案内容</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">tac</td>
<td align="center">从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">head</td>
<td align="center">只看头几行</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">tail</td>
<td align="center">只看尾几行</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">touch</td>
<td align="center">修改档案时间或新建档案</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">which</td>
<td align="center">搜索系统命令所在路径及别名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">whereis</td>
<td align="center">搜索系统命令所在位置</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">find</td>
<td align="center">查找符合条件的文件</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">zip 【压缩文件名】 【源文件】</td>
<td align="center">zip格式压缩文件</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">zip -r 【压缩文件名】 【源目录】</td>
<td align="center">zip格式压缩目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">unzip 【压缩文件】</td>
<td align="center">解压缩.zip文件</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">gzip 【源文件】</td>
<td align="center">压缩为.gz格式的压缩文件，源文件消失</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">gzip -c 【源文件】 &gt; 【压缩文件】</td>
<td align="center">压缩为.gz格式，源文件保留</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">gzip -d 【压缩文件】、gunzip 【压缩文件】</td>
<td align="center">解压缩.gz文件</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">bzip2 【源文件】</td>
<td align="center">压缩为.bz2格式，bu不保留源文件</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">bzip2 -k 【源文件】</td>
<td align="center">压缩后保留源文件</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">bzip2 -d 【压缩文件】、bunzip2 【压缩文件】</td>
<td align="center">解压缩，-k保留压缩文件</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">tar -cvf 【打包文件名】 【源文件】</td>
<td align="center">打包命令tar，用于解决目录不能被压缩的问题</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">tar -xvf 【打包文件名】</td>
<td align="center">解打包</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ls 【选项】 【文件或目录】</td>
<td align="center">-a</td>
<td align="center">显示所有文件，包括隐藏文件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-l</td>
<td align="center">显示详细信息</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-d</td>
<td align="center">查看目录属性</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-h</td>
<td align="center">人性化显示文件的大小</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-i</td>
<td align="center">显示inode</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">-a</td>
<td align="center">显示所有文件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-b</td>
<td align="center">带单位显示文件大小</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-d</td>
<td align="center">显示文件目录，不是内容</td>
</tr>
<tr>
<td align="center">vi/vim</td>
<td align="center">vim编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器;vi也是Linux中最基本的文本编辑器,vim就是vi的升级版。</td>
<td align="center">vi/vim可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）</td>
</tr>
<tr>
<td align="center">进入vi</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">vi filename</td>
<td align="center">打开或新建文件，并将光标置于第一行首</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">vi +n filename</td>
<td align="center">打开文件，并将光标置于第n行首</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">vi + filename</td>
<td align="center">打开文件，并将光标置于最后一行首</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">vi +/pattern filename</td>
<td align="center">打开文件，并将光标置于第一个与pattern匹配的串处</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">vi -r filename</td>
<td align="center">在上次正用vi编辑时发生系统崩溃，恢复filename</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">vi filename….filename</td>
<td align="center">打开多个文件，依次进行编辑</td>
</tr>
<tr>
<td align="center">切换至插入模式（Insert mode）编辑文件</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">按「i」切换进入插入模式「insert mode」，按”i”进入插入模式后是从光标当前位置开始输入文件；</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">退出vi及保存文件</td>
<td align="center">按「ESC」键，切换为命令行模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">: w filename</td>
<td align="center">（输入 「w filename」将文章以指定的文件名filename保存）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">: wq</td>
<td align="center">(输入「wq」，存盘并退出vi)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">: q!</td>
<td align="center">(输入q!， 不存盘强制退出vi)</td>
</tr>
<tr>
<td align="center">curl</td>
<td align="center">在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">curl [option] [url]</td>
<td align="center">基本用法：curl <a href="http://www.linux.com/">http://www.linux.com</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-A/–user-agent <string></td>
<td align="center">设置用户代理发送给服务器</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-b/–cookie &lt;name=string/file&gt;</td>
<td align="center">cookie字符串或文件读取位置</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-c/–cookie-jar <file></td>
<td align="center">操作结束后把cookie写入到这个文件中</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-C/–continue-at <offset></td>
<td align="center">断点续转</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-D/–dump-header <file></td>
<td align="center">把header信息写入到该文件中</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-e/–referer</td>
<td align="center">来源网址</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-f/–fail</td>
<td align="center">连接失败时不显示http错误</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-o/–output</td>
<td align="center">把输出写到该文件中</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-O/–remote-name</td>
<td align="center">把输出写到该文件中，保留远程文件的文件名</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-r/–range <range></td>
<td align="center">检索来自HTTP/1.1或FTP服务器字节范围</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-s/–silent</td>
<td align="center">静音模式。不输出任何东西</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-T/–upload-file <file></td>
<td align="center">上传文件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-u/–user &lt;user[:password]&gt;</td>
<td align="center">设置服务器的用户和密码</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-w/–write-out [format]</td>
<td align="center">什么输出完成后</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-x/–proxy &lt;host[:port]&gt;</td>
<td align="center">在给定的端口上使用HTTP代理</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-#/–progress-bar</td>
<td align="center">进度条显示当前的传送状态</td>
</tr>
<tr>
<td align="center">wget</td>
<td align="center">wget命令用来从指定的URL下载文件。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">wget(选项)(参数)</td>
<td align="center"></td>
<td align="center">wget <a href="http://test.com/testfile.zip">http://test.com/testfile.zip</a> -&gt;下载指定文件到当前文件夹</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-b</td>
<td align="center">进行后台的方式运行wget，wget -b <a href="http://www.linuxde.net/testfile.zip">http://www.linuxde.net/testfile.zip</a> -&gt;后台下载</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-c</td>
<td align="center">继续执行上次终端的任务；例：wget -c <a href="http://www.linuxde.net/testfile.zip">http://www.linuxde.net/testfile.zip</a> -&gt;断点续传</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-nc</td>
<td align="center">文件存在时，下载文件不覆盖原有文件；</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-nv</td>
<td align="center">下载时只显示更新和出错信息，不显示指令的详细执行过程；</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-q</td>
<td align="center">不显示指令执行过程；</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">v</td>
<td align="center">显示详细执行过程；</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-O，-output-document=file</td>
<td align="center">将下载内容写入到file文件中。wget -O wordpress.zip <a href="http://test.com/download">http://test.com/download</a> -&gt;指定保存名字</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">–limit-rate</td>
<td align="center">wget –limit-rate=300k <a href="http://www.linuxde.net/testfile.zip">http://www.linuxde.net/testfile.zip</a> -&gt;限制下载速度</td>
</tr>
<tr>
<td align="center">apt-get</td>
<td align="center">apt-get，是一条linux命令，适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。apt-get命令一般需要root权限执行，所以一般跟着sudo命令。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update：更新</td>
<td align="center">sudo apt-get update</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">upgrate：升级（dist-upgrade 不建议使用）</td>
<td align="center">sudo apt-get upgrade</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</td>
<td align="center">更新是更新包的数据库，让系统知道有新的包了。升级呢？是真的去升级，因此，这两个命令通常一起使用。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">install：安装</td>
<td align="center">sudo apt-get install <package_1> <package_2></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">remove：删除（只删除包的二进制文件。不会触及其他文件。程序就是可执行的二进制文件）</td>
<td align="center">apt-get remove packagename #卸载一个已安装的软件包（保留配置文档）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">purge：删除（删除与包相关的所有内容，包括配置文件）</td>
<td align="center">apt-get remove –purge packagename #卸载一个已安装的软件包（删除配置文档）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">clean ：清除检索到的包文件的本地存储库</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">autoclean：删除现在有更新版本的检索包文件，它们将不再使用</td>
<td align="center">sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">autoremove：删除自动安装的lib和软件包，以满足以安装软件的依赖关系</td>
<td align="center">apt-get autoremove packagename #删除包及其依赖的软件包</td>
</tr>
<tr>
<td align="center">apt-cache</td>
<td align="center">search：搜索包</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">pkgnames：搜索具有特定名称的包</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">showpkg：查看包的详细信息</td>
<td align="center"></td>
</tr>
</tbody></table>
<h5 id="Linux下载：wget、curl、yum与apt-get用法及区别"><a href="#Linux下载：wget、curl、yum与apt-get用法及区别" class="headerlink" title="Linux下载：wget、curl、yum与apt-get用法及区别"></a>Linux下载：wget、curl、yum与apt-get用法及区别</h5><p>一般来说著名的linux系统基本上分两大类：</p>
<ul>
<li>RedHat系列：Redhat、Centos、Fedora等</li>
<li>Debian系列：Debian、Ubuntu等</li>
</ul>
<p>RedHat 系列</p>
<ul>
<li>常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数”</li>
<li>包管理工具 yum</li>
<li>支持tar包</li>
</ul>
<p>Debian系列</p>
<ol>
<li>常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数”</li>
<li>包管理工具 apt-get</li>
<li>支持tar包</li>
</ol>
<p>yum可以用于运作rpm包，能够从指定资源服务器下载rpm安装包并自动安装，可以自动处理依赖关系，并且一次性安装所有的依赖包，例如在Fedora系统上对某个软件的管理：</p>
<ol>
<li>安装：yum install</li>
<li>卸载：yum remove</li>
<li>更新：yum update</li>
</ol>
<p>apt-get可以用于运作deb包，例如在Ubuntu系统上对某个软件的管理：</p>
<ol>
<li>安装：apt-get install</li>
<li>卸载：apt-get remove</li>
<li>更新：apt-get update</li>
</ol>
<p>​    wget不是安装方式，而是一种下载工具，简单，专一，极致；而curl可以下载，但是长项不在于下载，而在于模拟提交web数据，POST/GET请求，调试网页，等等。在下载上，也各有所长，wget可以递归，支持断点；而curl支持URL中加入变量，因此可以批量下载。综上，curl由于可自定义各种请求参数所以在模拟web请求方面更擅长；wget由于支持ftp和Recursive所以在下载文件方面更擅长。类比的话curl是浏览器，而wget是迅雷9。</p>
<p>如果当前ubuntu未安装wget，可按下列操作进行安装和检查是否安装成功：</p>
<ul>
<li>sudo apt-get update</li>
<li>sudo apt-get install wget</li>
<li>wget –version</li>
</ul>
<h3 id="作业2补充：yum是什么"><a href="#作业2补充：yum是什么" class="headerlink" title="作业2补充：yum是什么"></a>作业2补充：yum是什么</h3><p>中文名：Shell前端软件包管理器</p>
<p><a href="http://www.yanghengfei.com/tag/yum/">yum</a>（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基于RPM包(RPM 是 Red Hat Package Manager 的缩写，本意是Red Hat 软件包管理，顾名思义是Red Hat 贡献出来的软件包管理)管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
<p>yum的宗旨是自动化地升级，安装/移除rpm包，收集rpm包的相关信息，检查依赖性并自动提示用户解决。yum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，</p>
<h3 id="作业2补充：了解学习oh-my-zsh"><a href="#作业2补充：了解学习oh-my-zsh" class="headerlink" title="作业2补充：了解学习oh-my-zsh"></a>作业2补充：了解学习oh-my-zsh</h3><p>1.zsh是ubuntu的一个命令行插件，兼容 Bash，据传说 99% 的 Bash 操作 和 Zsh 是相同的，默认 CentOS / Ubuntu / Mac 系统用的是 Bash。</p>
<p>2.zsh和bash是两个不同的概念，zsh是bash的增强版，zsh更加强大。通常zsh配置起来非常麻烦，且相当的复杂，所以oh-my-zsh是为了简化zsh的配置而开发的，因此oh-my-zsh算是zsh的配置。</p>
<p>3.<code>oh-my-zsh</code> 的强大：</p>
<p>a.<strong>主题选择</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim ~&#x2F;.zshrc</span><br><span class="line">#修改主题名称</span><br><span class="line">ZSH_THEME&#x3D;&quot;ys&quot;</span><br><span class="line">#然后重新加载配置文件，每次修改配置文件后，都需要再次加载配置文件才能生效</span><br><span class="line">$ source ~&#x2F;.zshrc</span><br></pre></td></tr></table></figure>

<p>b.<strong>插件</strong></p>
<p>oh-my-zsh默认安装了git插件，在git仓库中，会提示当前所在的分支。此外，还有大量优秀的插件，比如：extract、z、zsh-autosuggestions，具体可查看插件仓库<a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins">https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins</a>.</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>http-server安装和启动</title>
    <url>/2020/10/19/kuku_class_homework_dayao/class1_environment_setting/http-server%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="http-server安装和启动"><a href="#http-server安装和启动" class="headerlink" title="http-server安装和启动"></a>http-server安装和启动</h2><p>​    Http-server是一个基于nodejs的轻量级的http服务器，它最大好处就是：可以使任意一个本地目录开起成为一个本地服务器。比如，vue项目执行build构建，会生成一个dist目录，我们若想将项目部署到服务器，除了通过复制dist静态文件到服务器nginx目录下，然后启动nginx来启动项目，另外一个办法就是安装http-server 直接启动本地服务。</p>
<h3 id="下面则是http-server安装和启动："><a href="#下面则是http-server安装和启动：" class="headerlink" title="下面则是http-server安装和启动："></a>下面则是http-server安装和启动：</h3><p>​    参考：<a href="https://www.npmjs.com/package/http-server">https://www.npmjs.com/package/http-server</a></p>
<h5 id="全局安装："><a href="#全局安装：" class="headerlink" title="全局安装："></a>全局安装：</h5><p><code>npm install --global http-server</code></p>
<h5 id="作为npm包依赖安装："><a href="#作为npm包依赖安装：" class="headerlink" title="作为npm包依赖安装："></a>作为npm包依赖安装：</h5><p><code>npm install http-server</code></p>
<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>终端进入你想要成为服务器的目录下，运行如下命令</p>
<p><code>http-server</code></p>
<p>若要禁用缓存，请使用如下命令运行</p>
<p><code>http-server -c-1</code></p>
<p>执行成功后，在浏览器输入<a href="http://localhost:8080/%E6%88%96%E8%80%85http://127.0.0.1:8080%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E4%BD%A0%E5%BE%97%E6%96%87%E4%BB%B6%E4%BA%86%E3%80%82">http://localhost:8080/或者http://127.0.0.1:8080就可以访问你得文件了。</a></p>
<h5 id="停止运行"><a href="#停止运行" class="headerlink" title="停止运行"></a>停止运行</h5><p>Ctrl+C</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>安装适用于Windows的Linux子系统</title>
    <url>/2020/10/19/kuku_class_homework_dayao/class1_environment_setting/%E5%AE%89%E8%A3%85%E9%80%82%E7%94%A8%E4%BA%8EWindows%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="安装适用于Windows的Linux子系统"><a href="#安装适用于Windows的Linux子系统" class="headerlink" title="安装适用于Windows的Linux子系统"></a>安装适用于Windows的Linux子系统</h2><p>安装成功后，可以通过Hyper终端，连接ubuntu，使用linux命令直接操作Windows中的fs。</p>
<p>参考：<a href="https://evdokimovm.github.io/windows/zsh/shell/syntax/highlighting/ohmyzsh/hyper/terminal/2017/02/24/how-to-install-zsh-and-oh-my-zsh-on-windows-10.html">https://evdokimovm.github.io/windows/zsh/shell/syntax/highlighting/ohmyzsh/hyper/terminal/2017/02/24/how-to-install-zsh-and-oh-my-zsh-on-windows-10.html</a></p>
<h3 id="安装步骤如下："><a href="#安装步骤如下：" class="headerlink" title="安装步骤如下："></a>安装步骤如下：</h3><h4 id="1-将windows设置成开发人员模式"><a href="#1-将windows设置成开发人员模式" class="headerlink" title="1.将windows设置成开发人员模式"></a>1.将windows设置成开发人员模式</h4><p>设置——开发者选项——开发人员模式</p>
<h4 id="2-从windows-store安装ubuntu"><a href="#2-从windows-store安装ubuntu" class="headerlink" title="2.从windows store安装ubuntu"></a>2.从windows store安装ubuntu</h4><p>参考：<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10%EF%BC%8C%E5%8F%AA%E8%A7%81%E6%AD%A5%E9%AA%A46%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%AE%89%E8%A3%85ubuntu%E5%8D%B3%E5%8F%AF%E3%80%82%E5%9C%A8%E5%AE%89%E8%A3%85Ubuntu%E5%B9%B6%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8PC%E5%90%8E%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%E4%B8%8B%E4%BD%BF%E7%94%A8bash%E6%88%96ubuntu%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E5%AE%83">https://docs.microsoft.com/zh-cn/windows/wsl/install-win10，只见步骤6，直接安装ubuntu即可。在安装Ubuntu并重新启动PC后，可以在命令提示符下使用bash或ubuntu命令运行它</a></p>
<h4 id="3-安装-Hyper-Terminal"><a href="#3-安装-Hyper-Terminal" class="headerlink" title="3.安装 Hyper Terminal"></a>3.安装 Hyper Terminal</h4><p>去<a href="https://hyper.is/%EF%BC%8C%E5%AE%89%E8%A3%85%E9%80%82%E5%90%88%E6%9C%AC%E6%9C%BA%E7%9A%84Hyper">https://hyper.is/，安装适合本机的Hyper</a></p>
<h4 id="4-安装Zsh和Oh-My-Zsh"><a href="#4-安装Zsh和Oh-My-Zsh" class="headerlink" title="4.安装Zsh和Oh My Zsh"></a>4.安装Zsh和Oh My Zsh</h4><p>启动ubuntu，安装zsh和 oh-my-zsh</p>
<p>安装Zsh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;sudo apt-get install zsh&#96;</span><br></pre></td></tr></table></figure>

<p>oh-my-zsh地址：<a href="https://github.com/ohmyzsh/ohmyzsh">https://github.com/ohmyzsh/ohmyzsh</a></p>
<p>作用：</p>
<p>1.zsh和bash是两个不同的概念，zsh是bash的增强版，zsh更加强大。通常zsh配置起来非常麻烦，且相当的复杂，所以oh-my-zsh是为了简化zsh的配置而开发的，因此oh-my-zsh算是zsh的配置。</p>
<p>2.<code>oh-my-zsh</code> 的强大：</p>
<p>a.<strong>主题选择</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim ~&#x2F;.zshrc</span><br><span class="line">#修改主题名称</span><br><span class="line">ZSH_THEME&#x3D;&quot;ys&quot;</span><br><span class="line">#然后重新加载配置文件，每次修改配置文件后，都需要再次加载配置文件才能生效</span><br><span class="line">$ source ~&#x2F;.zshrc</span><br></pre></td></tr></table></figure>

<p>b.<strong>插件</strong></p>
<p>oh-my-zsh默认安装了git插件，在git仓库中，会提示当前所在的分支。此外，还有大量优秀的插件，比如：extract、z、zsh-autosuggestions，具体可查看插件仓库<a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins">https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins</a>.</p>
<p>安装oh-my-zsh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh | bash&#96;</span><br></pre></td></tr></table></figure>

<p>注意：这里容易出现443，需要在hosts配置文件中增加199.232.68.133 raw.githubusercontent.com</p>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;sudo vim &#x2F;etc&#x2F;hosts&#96;</span><br></pre></td></tr></table></figure>

<p>hosts文件位于” C:\Windows\System32\drivers\etc “目录下，主要作用是定义IP地址和主机名的映射关系，是一个映射IP地址和主机名的规定。在浏览器中通过域名访问网站，首先查看hosts文件中是否存在域名与IP的地址转换，如果存在则直接根据IP地址进行访问；否则向DNS服务器发送请求，根据返回结果中的IP进行访问。</p>
<p>hosts文件作用：</p>
<p>​    1.提升网站的访问速度。如果在hosts中配置了常用的网址和IP的映射关系，就省去了向DNS服务器发送请求获取IP的过程，从而更快的访问网站速度。</p>
<p>​    2.记录常用IP地址</p>
<h4 id="5-配置并运行我的Zsh"><a href="#5-配置并运行我的Zsh" class="headerlink" title="5.配置并运行我的Zsh"></a>5.配置并运行我的Zsh</h4><p>打开ubuntu，执行 chsh -s /usr/bin/zsh，它将zsh作为默认的shell环境自动运行</p>
<h4 id="6-配置并运行超级终端"><a href="#6-配置并运行超级终端" class="headerlink" title="6.配置并运行超级终端"></a>6.配置并运行超级终端</h4><p>安装超级终端后，打开<code>%USERPROFILE%/.hyper.js</code>配置文件并替换行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell: &#39;&#39;,</span><br><span class="line">shellArgs: [&#39;--login&#39;],</span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell: &#39;C:\\Windows\\System32\\cmd.exe&#39;,</span><br><span class="line">shellArgs: [&#39;--login&#39;, &#39;-i&#39;, &#39;&#x2F;c wsl&#39;],</span><br></pre></td></tr></table></figure>

<h4 id="7-更换终端"><a href="#7-更换终端" class="headerlink" title="7.更换终端"></a>7.更换终端</h4><p>可以使用下列命令在不同终端间切换。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh <span class="comment">#切换为zsh</span></span><br><span class="line">chsh -s /bin/bash <span class="comment">#切换回bash</span></span><br></pre></td></tr></table></figure>

<h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h4><p>​    zsh是ubuntu的一个命令行插件，兼容 Bash，据传说 99% 的 Bash 操作 和 Zsh 是相同的，默认 CentOS / Ubuntu / Mac 系统用的是 Bash。</p>
<p>​    要注意的是，如果之前有配置在bash中的配置文件，切换了终端之后会无法使用，需要在zsh终端重新配置。一般来说，bash的配置文件在<del>/.bashrc 或者</del>/.bash_profile中，而zsh则在~/.zshrc中。</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>VPN配置</title>
    <url>/2020/10/19/kuku_class_homework_dayao/class1_environment_setting/VPN%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="VPN配置"><a href="#VPN配置" class="headerlink" title="VPN配置"></a>VPN配置</h2><h4 id="工具安装："><a href="#工具安装：" class="headerlink" title="工具安装："></a>工具安装：</h4><p>VPN tool：<a href="https://github.com/Kr328/ClashForAndroid">https://github.com/Kr328/ClashForAndroid</a><br>mac VPN tool: <a href="https://github.com/yichengchen/clashX">https://github.com/yichengchen/clashX</a><br>windows VPN tool: <a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a></p>
<h4 id="Profiles-Url"><a href="#Profiles-Url" class="headerlink" title="Profiles Url"></a>Profiles Url</h4><p><a href="https://feedneo.net/files/BSJsg8hV9o/clash.yml">https://feedneo.net/files/BSJsg8hV9o/clash.yml</a></p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>windows安装nvm与node</title>
    <url>/2020/10/19/kuku_class_homework_dayao/class1_environment_setting/windows%E5%AE%89%E8%A3%85nvm%E4%B8%8Enode/</url>
    <content><![CDATA[<h2 id="windows安装nvm与node"><a href="#windows安装nvm与node" class="headerlink" title="windows安装nvm与node"></a>windows安装nvm与node</h2><p>nvm是nodejs版本管理工具，通过它可以方便地在本地切换node版本。</p>
<h3 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h3><p>系统：</p>
<p>​    win10</p>
<p>nvm与node安装路径：</p>
<p>​    D:\nvm</p>
<p>​    D:\nodejs</p>
<p>参考：<a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p>
<h3 id="问题主线："><a href="#问题主线：" class="headerlink" title="问题主线："></a>问题主线：</h3><p>第一步：nvm安装成功</p>
<p>第二步：nvm install <version></p>
<p>第三步: nvm ls，刚刚安装的node版本已经存在，貌似成功</p>
<p>第四步：nvm use <version>切换node版本，成功</p>
<p>第五步：node  -v，检验node报错。即使node成功后，在执行npm - v，npm仍然报错，windows真的好硬核。错误内容可能有如下几种（本人踩坑的几种）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Bug One&gt;：</span><br><span class="line">node : 无法将“node”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写， 如果包括路径，请确保路径正确</span><br><span class="line">，然后再试一次。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ node</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (node:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br><span class="line">解决:我最开始出现的原因是因为我之前装过一个node，没有删除，又接着装nvm，导致之前的node版本把nvm中的node覆盖了。后来，又出现了这个bug，是因为重装之后，在nodejs安装路径下，所安装的node文件名是node64.exe，而不再是node.exe，于是直接重命名，64去掉，node正常了。</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">程序“node.exe”无法运行: 指定的可执行文件不是此操作系统平台的有效应用程序。所在位置 行:1 字符: 1</span><br><span class="line">+ node</span><br><span class="line">+ ~~~~。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ node</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : ResourceUnavailable: (:) [], ApplicationFailedException</span><br><span class="line">    + FullyQualifiedErrorId : NativeCommandFailed</span><br><span class="line">解决：重装。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Bug Two&gt;：</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">都出现：拒绝访问</span><br><span class="line">解决：这是因为你的node、npm都没有安装成功，或者安装错误。去nvm安装路径下D:\nvm\v12.19.0\node_modules查看，发现真的是空的，没有npm，而npm安装失败极有可能就是网络问题，那就换镜像源吧</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Bug Three&gt;：</span><br><span class="line">wsarecv: An existing connection was forcibly closed by the remote host.</span><br><span class="line">解决：换镜像源</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Bug Four&gt;：</span><br><span class="line">Failed to extract npm. Could not find D:\nvm\temp\nvm-npm\npm-6.14.8\bin</span><br><span class="line">解决：查nvm配置文件，查环境变量。bug2和3，其实就是告诉你，你的node或者npm实际上是没有安装成功的</span><br></pre></td></tr></table></figure>

<p>注意：nvm ls命令列出来当前安装的node，并非真实成功安装的node。似乎只要你执行了nvm install <version>,nvm就会默认当前版本是已安装，但这并不能说明你真的就安装成功了。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.更换node和npm镜像源：</p>
<p>将D:\nvm\settings内容修改如下：</p>
<p>root: D:\nvm<br>path: D:\nodejs<br>arch: 64<br>node_mirror: <a href="https://npm.taobao.org/mirrors/node/">https://npm.taobao.org/mirrors/node/</a><br>npm_mirror: <a href="https://npm.taobao.org/mirrors/npm/">https://npm.taobao.org/mirrors/npm/</a></p>
<p>2.如果在安装nvm之前安装过node，请把node删除干净，在重装nvm，以及后面一系列。</p>
<p>3.如果之前执行nvm install  <version>，但没有成功安装，需要清除，清除旧版本，即nvm uninstall <version>，或者手动删除D:/nvm/<version>/，否则会提示版本已存在。</p>
<p>4.node -v不成功，你就有必要怀疑电脑真的有正确安装么，nvm  ls说明不了什么，别信它，去安装路径下看看。</p>
<p>5.npm  -v 不成功，或者缺少vue cli。</p>
<p>在执行nvm install <version>的时候，会在D:\nvm文件夹下创建一个temp文件夹，npm的安装包就会下载在这里，但是注意：下载的安装包为D:\nvm\temp\npm-v<version>.zip，这个包安装完后会被删除，文件夹会清空，只留下一个压缩包。所以，卡好时间，在下载完，安装中的时间点，把安装包copy出来。最后，提示安装完成，你会发现D:\nvm\v<version>\node_modules下空空如也，这也是为什么npm -v有问题，因为压根没存在。然后，将之前copy的包下的cli-<version>放到D:\nvm\v<version>\node_modules下，重命名为npm。最后，npm -v执行成功。 </p>
<p>6.简直就是个会移动会变化的bug，神奇的不行！每一次重装得到的结果、出现的错误、不同的时间、bug好像都不太一样，真的是厉害了！然后，一天又过去了！</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX简介与技术点</title>
    <url>/2020/10/11/kuku_class_homework_dayao/class2_homework/class2-ajax%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%82%B9/</url>
    <content><![CDATA[<h1 id="AJAX简介与技术点"><a href="#AJAX简介与技术点" class="headerlink" title="AJAX简介与技术点"></a>AJAX简介与技术点</h1><h2 id="1-1、ajax简介"><a href="#1-1、ajax简介" class="headerlink" title="1-1、ajax简介"></a>1-1、ajax简介</h2><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>
<p>AJAX 不是新的编程语言，而是一种使用现有标准的、用于创建快速动态网页的新方法。</p>
<p>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>
<h2 id="1-2、Ajax所包含的技术"><a href="#1-2、Ajax所包含的技术" class="headerlink" title="1-2、Ajax所包含的技术"></a>1-2、Ajax所包含的技术</h2><p>大家都知道ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。</p>
<blockquote>
<p>1.使用CSS和XHTML来表示。</p>
<p>2.使用DOM模型来交互和动态显示。</p>
<p>3.使用XMLHttpRequest来和服务器进行异步通信。</p>
<p>4.使用javascript来绑定和调用。</p>
</blockquote>
<p>AJAX 的核心是 XMLHttpRequest 对象。</p>
<p>不同的浏览器创建 XMLHttpRequest 对象的方法是有差异的。</p>
<h2 id="1-3、为什么需要使用ajax"><a href="#1-3、为什么需要使用ajax" class="headerlink" title="1-3、为什么需要使用ajax"></a>1-3、为什么需要使用ajax</h2><p>ajax主要是实现页面和web服务器之间数据的异步传输。简单来说，不采用ajax的页面，当用户在页面发起请求时，就要进行整个页面的刷新，刷新快慢取决于服务器的处理快慢。在这个过程中用户必须得等待，不能进行其他操作。也就是同步的方式。客户端和服务端传递了很多不需要的数据。效率低，用户体验差。</p>
<ul>
<li>a、采用ajax的页面，可以实现页面的局部更新，而不是整个页面的更新；</li>
<li>b、并且发起请求后，用户还可以进行页面上的其他操作。这就是异步的方式。</li>
<li>c、客户端和服务端间只传递需要的数据，效率高，用户体验性好。</li>
<li>d、并且Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。</li>
</ul>
<h2 id="1-4、Ajax的工作原理"><a href="#1-4、Ajax的工作原理" class="headerlink" title="1-4、Ajax的工作原理"></a>1-4、Ajax的工作原理</h2><p>Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎)，使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器。像—些数据验证和数据处理等都交给Ajax引擎自己来做,，只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p>
<p>AJAX是通过浏览器的内置对象XHMHttpResquest来发送异步请求的，异步请求不会妨碍客户端的任何操作。</p>
<ul>
<li><p>异步：</p>
<p>XHR相当于是一个通信兵，来负责客户端与服务器之间的通信传输。举个栗子：</p>
<p>要打仗了，前方阵地（客服端）不可能只等着通信兵（XHR）传递消息其他什么也不干吧，所以前方阵地还在干着自己的事情然后派通信兵去请求后方指挥部（服务器）的命令，指挥部下达命令指挥，通信兵再把命令传到前方阵地，然后前方阵地再执行命令相关的操作（客户端把数据渲染到页面），这也就是Ajax的异步原理。</p>
</li>
<li><p>同步：</p>
<p>所谓的同步就是前方阵地和通信兵一起去向服务器请求数据，直到通信兵请求到数据，我才开始渲染页面，在请求的过程中页面一直是白屏等待的。</p>
</li>
</ul>
<h2 id="1-5、XMLHttpRequest-对象的三个常用的属性"><a href="#1-5、XMLHttpRequest-对象的三个常用的属性" class="headerlink" title="1-5、XMLHttpRequest 对象的三个常用的属性"></a>1-5、XMLHttpRequest 对象的三个常用的属性</h2><h3 id="1-onreadystatechange-属性"><a href="#1-onreadystatechange-属性" class="headerlink" title="1. onreadystatechange 属性"></a>1. onreadystatechange 属性</h3><p>onreadystatechange 属性存有处理服务器响应的函数。<br>下面的代码定义一个空的函数，可同时对 onreadystatechange 属性进行设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//我们需要在这写一些代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-readyState-属性"><a href="#2-readyState-属性" class="headerlink" title="2. readyState 属性"></a><strong>2. readyState 属性</strong></h3><p>readyState 属性存有服务器响应的状态信息。每当 readyState 改变时，onreadystatechange 函数就会被执行。<br>readyState 属性可能的值：</p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">请求未初始化（在调用 open() 之前）</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">请求已提出（调用 send() 之前）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">请求已发送（这里通常可以从响应得到内容头部）</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">请求处理中（响应中通常有部分数据可用，但是服务器还没有完成响应）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">请求已完成（可以访问服务器响应并使用它）</td>
</tr>
</tbody></table>
<p>我们要向这个 onreadystatechange 函数添加一条 If 语句，来测试我们的响应是否已完成(意味着可获得数据)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">//从服务器的response获得数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-responseText-属性"><a href="#3-responseText-属性" class="headerlink" title="3. responseText 属性"></a><strong>3. responseText 属性</strong></h3><p>可以通过 responseText 属性来取回由服务器返回的数据。<br>在我们的代码中，我们将把时间文本框的值设置为等于 responseText：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.myForm.time.value = xmlHttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-xmlhttprequst的方法"><a href="#1-6-xmlhttprequst的方法" class="headerlink" title="1-6 xmlhttprequst的方法"></a>1-6 xmlhttprequst的方法</h2><h3 id="1-open-方法"><a href="#1-open-方法" class="headerlink" title="1. open() 方法"></a><strong>1. open() 方法</strong></h3><p>open() 有三个参数。第一个参数定义发送请求所使用的方法，第二个参数规定服务器端脚本的URL，第三个参数规定应当对请求进行异步地处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlHttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;test.php&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-send-方法"><a href="#2-send-方法" class="headerlink" title="2. send() 方法"></a><strong>2. send() 方法</strong></h3><p>send() 方法将请求送往服务器。如果我们假设 HTML 文件和 PHP 文件位于相同的目录，那么代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlHttp.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="1-7Ajax编程步骤"><a href="#1-7Ajax编程步骤" class="headerlink" title="1-7Ajax编程步骤"></a>1-7Ajax编程步骤</h2><p>为了方便理解，给AJAX统一了一个流程，要想实现AJAX，就要按照以后步骤走：</p>
<blockquote>
<ol>
<li>创建XMLHttpRequest对象。</li>
<li>设置请求方式。</li>
<li>调用回调函数。</li>
<li>发送请求。</li>
</ol>
</blockquote>
<p>下面来看下具体步骤：</p>
<h3 id="1-创建XMLHttpRequest对象"><a href="#1-创建XMLHttpRequest对象" class="headerlink" title="1. 创建XMLHttpRequest对象"></a>1. 创建XMLHttpRequest对象</h3><p>创建XMLHttp对象的语法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp=<span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<p>如果是IE5或者IE6浏览器，则使用<strong>ActiveX</strong>对象，创建方法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>一般我们手写AJAX的时候，首先要判断该浏览器是否支持XMLHttpRequest对象，如果支持则创建该对象，如果不支持则创建ActiveX对象。JS代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：创建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;            <span class="comment">//非IE</span></span><br><span class="line">    xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;       <span class="comment">//IE</span></span><br><span class="line">    xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-设置请求方式"><a href="#2-设置请求方式" class="headerlink" title="2. 设置请求方式"></a>2. 设置请求方式</h3><p>在WEB开发中，请求有两种形式，一个是get，一个是post，所以在这里需要设置一下具体使用哪个请求，XMLHttpRequest对象的open()方法就是来设置请求方式的。<br>open()方法</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>规定请求的类型、URL 以及是否异步处理请求</td>
<td>参数1：设置请求类型（GET 或 POST），GET与POST的区别请自己百度一下，这里不做解释； 参数2：文件在服务器上的位置； 参数3：是否异步处理请求，是为true，否为false。</td>
</tr>
</tbody></table>
<p>如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二步：设置和服务器端交互的相应参数，向路径http://localhost:8080/JsLearning3/getAjax准备发送数据</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://localhost:8080/JsLearning3/getAjax&quot;</span>;</span><br><span class="line">xmlHttp.open(<span class="string">&quot;POST&quot;</span>, url, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="GET-还是-POST？"><a href="#GET-还是-POST？" class="headerlink" title="GET 还是 POST？"></a><strong>GET 还是 POST？</strong></h4><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求：</p>
<blockquote>
<p>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
</blockquote>
<h4 id="异步-True-或-False？"><a href="#异步-True-或-False？" class="headerlink" title="异步 - True 或 False？"></a><strong>异步 - True 或 False？</strong></h4><p>​    AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true：对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。<br>通过 AJAX，JavaScript 无需等待服务器的响应，而是：<br>在等待服务器响应时执行其他脚本<br>当响应就绪后对响应进行处理</p>
<h3 id="3-调用回调函数"><a href="#3-调用回调函数" class="headerlink" title="3. 调用回调函数"></a>3. 调用回调函数</h3><p>如果在上一步中open方法的第三个参数选择的是true，那么当前就是异步请求，这个时候需要写一个回调函数，XMLHttpRequest对象有一个onreadystatechange属性，这个属性返回的是一个匿名的方法，所以回调函数就在这里写xmlHttp.onreadystatechange=function{},function{}内部就是回调函数的内容。所谓回调函数，就是请求在后台处理完，再返回到前台所实现的功能。在这个例子里，我们的回调函数要实现的功能就是接收后台处理后反馈给前台的数据，然后将这个数据显示到指定的div上。因为从后台返回的数据可能是错误的，所以在回调函数中首先要判断后台返回的信息是否正确，如果正确才可以继续执行。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三步：注册回调函数</span></span><br><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlHttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">            obj.innerHTML = xmlHttp.responseText;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">&quot;AJAX服务器返回错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，xmlHttp.readyState是存有XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化。1: 服务器连接已建立。2: 请求已接收。3: 请求处理中。4: 请求已完成，且响应已就绪。所以这里我们判断只有当xmlHttp.readyState为4的时候才可以继续执行。</p>
<p>xmlHttp.status是服务器返回的结果，其中200代表正确。404代表未找到页面，所以这里我们判断只有当xmlHttp.status等于200的时候才可以继续执行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = document.getElementById(id);</span><br><span class="line">obj.innerHTML = xmlHttp.responseText;</span><br></pre></td></tr></table></figure>

<p>这段代码就是回调函数的核心内容，就是获取后台返回的数据，然后将这个数据赋值给id为testid的div。xmlHttp对象有两个属性都可以获取后台返回的数据，分别是：responseText和responseXML，其中responseText是用来获得<strong>字符串形式</strong>的响应数据，responseXML是用来获得 <strong>XML 形式</strong>的响应数据。至于选择哪一个是取决于后台给返回的数据的，这个例子里我们只是显示一条字符串数据所以选择的是responseText。</p>
<h4 id="AJAX状态值与状态码区别"><a href="#AJAX状态值与状态码区别" class="headerlink" title="AJAX状态值与状态码区别"></a><strong>AJAX状态值与状态码区别</strong></h4><p> <strong><em>AJAX状态值是指</em></strong>，运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用“ajax.readyState”获得。（由数字1~4单位数字组成）<br><strong>AJAX状态码是指</strong>，无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用“ajax.status”所获得；（由数字1XX,2XX三位数字组成，详细查看RFC）<br>这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(<span class="params">ajax.readyState == <span class="number">4</span> &amp;&amp; ajax.status == <span class="number">200</span></span>)</span> &#123;。。。。);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AJAX运行步骤与状态值说明"><a href="#AJAX运行步骤与状态值说明" class="headerlink" title="AJAX运行步骤与状态值说明"></a><strong>AJAX运行步骤与状态值说明</strong></h4><p>在AJAX实际运行当中，对于访问XMLHttpRequest（XHR）时并不是一次完成的，而是分别经历了多种状态后取得的结果，对于这种状态在AJAX中共有5种，分别是：<br>0 - (未初始化)还没有调用send()方法<br>1 - (载入)已调用send()方法，正在发送请求<br>2 - (载入完成)send()方法执行完成，<br>3 - (交互)正在解析响应内容<br>4 - (完成)响应内容解析完成，可以在客户端调用了<br>对于上面的状态，其中“0”状态是在定义后自动具有的状态值，而对于成功访问的状态（得到信息）我们大多数采用“4”进行判断。</p>
<h4 id="AJAX状态码说明"><a href="#AJAX状态码说明" class="headerlink" title="AJAX状态码说明"></a><strong>AJAX状态码说明</strong></h4><p>1：请求收到，继续处理<br>2：操作成功收到，分析、接受<br>3：完成此请求必须进一步处理<br>4：请求包含一个错误语法或不能完成<br>5：服务器执行一个完全有效请求失败</p>
<p>再具体就如下：</p>
<p>100——客户必须继续发出请求<br>101——客户要求服务器根据请求转换HTTP协议版本<br>200——交易成功<br>201——提示知道新文件的URL<br>202——接受和处理、但处理未完成<br>203——返回信息不确定或不完整<br>204——请求收到，但返回信息为空<br>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>206——服务器已经完成了部分用户的GET请求<br>300——请求的资源可在多处得到<br>301——删除请求数据<br>302——在其他地址发现了请求数据<br>303——建议客户访问其他URL或访问方式<br>304——客户端已经执行了GET，但文件未变化<br>305——请求的资源必须从服务器指定的地址得到<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>307——申明请求的资源临时性删除<br>400——错误请求，如语法错误<br>401——请求授权失败<br>402——保留有效ChargeTo头响应<br>403——请求不允许<br>404——没有发现文件、查询或URl<br>405——用户在Request-Line字段定义的方法不允许<br>406——根据用户发送的Accept拖，请求资源不可访问<br>407——类似401，用户必须首先在代理服务器上得到授权<br>408——客户端没有在用户指定的饿时间内完成请求<br>409——对当前资源状态，请求不能完成<br>410——服务器上不再有此资源且无进一步的参考地址<br>411——服务器拒绝用户定义的Content-Length属性请求<br>412——一个或多个请求头字段在当前请求中错误<br>413——请求的资源大于服务器允许的大小<br>414——请求的资源URL长于服务器允许的长度<br>415——请求资源不支持请求项目格式<br>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求<br>500——服务器产生内部错误<br>501——服务器不支持请求的函数<br>502——服务器暂时不可用，有时是为了防止发生系统过载<br>503——服务器过载或暂停维修<br>504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长<br>505——服务器不支持或拒绝支请求头中指定的HTTP版本</p>
<h2 id="2-4-发送请求"><a href="#2-4-发送请求" class="headerlink" title="2.4 发送请求"></a>2.4 发送请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第四步：设置发送请求的内容和发送报送。然后发送请求</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="string">&quot;userName=&quot;</span> + <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;userName&quot;</span>)[<span class="number">0</span>].value + <span class="string">&quot;&amp;userPass=&quot;</span> + <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;userPass&quot;</span>)[<span class="number">0</span>].value + <span class="string">&quot;&amp;time=&quot;</span> + <span class="built_in">Math</span>.random();  <span class="comment">// 增加time随机参数，防止读取缓存 		</span></span><br><span class="line">xmlHttp.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;</span>);                     <span class="comment">// 向请求添加 HTTP 头，POST如果有数据一定加加！！！！</span></span><br><span class="line">xmlHttp.send(params);</span><br></pre></td></tr></table></figure>

<p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_37580235/article/details/81459282">https://blog.csdn.net/weixin_37580235/article/details/81459282</a></p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>kuku-class-homework-dayao</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>kuku-class-homework-dayao</tag>
      </tags>
  </entry>
</search>
